"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/page",{

/***/ "(app-pages-browser)/./src/lib/api/documents.ts":
/*!**********************************!*\
  !*** ./src/lib/api/documents.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupBlobUrls: function() { return /* binding */ cleanupBlobUrls; },\n/* harmony export */   documentsApi: function() { return /* binding */ documentsApi; }\n/* harmony export */ });\n/* harmony import */ var _apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiService */ \"(app-pages-browser)/./src/lib/api/apiService.ts\");\n/* harmony import */ var _validation_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/validation/schemas */ \"(app-pages-browser)/./src/validation/schemas.ts\");\n\n\n// API base URL - would be configured based on environment\nconst API_BASE_URL = \"http://localhost:8000\" || 0;\n// Function to handle API errors - keeping for backwards compatibility\nconst handleApiError = (error)=>{\n    console.error(\"API Error:\", error);\n    if (error.response && error.response.data && error.response.data.detail) {\n        throw new Error(error.response.data.detail);\n    }\n    throw new Error(\"An error occurred while communicating with the server\");\n};\n// Store created blob URLs for later cleanup\nconst createdBlobUrls = [];\n// Add a function to clean up blob URLs\nconst cleanupBlobUrls = ()=>{\n    createdBlobUrls.forEach((url)=>{\n        try {\n            URL.revokeObjectURL(url);\n        } catch (e) {\n            console.error(\"Error revoking URL:\", e);\n        }\n    });\n    createdBlobUrls.length = 0; // Clear the array\n};\nconst documentsApi = {\n    /**\n   * Uploads a document to the server\n   */ async uploadDocument (file) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Type assertion to resolve schema compatibility issue\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.postFormData(\"/api/documents/upload\", formData, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // For now, return a placeholder ProcessedDocument until re-processing is complete\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Lists all documents\n   */ async listDocuments () {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents?page=\".concat(page, \"&page_size=\").concat(pageSize));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Gets document count\n   */ async getDocumentCount () {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/count\");\n            return response.count;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Checks if a document has valid financial data\n   */ async checkDocumentFinancialData (documentId) {\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Verify a document's financial data and optionally trigger re-extraction\n   */ async verifyDocumentFinancialData (documentId) {\n        let retryExtraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // First check if document has financial data\n            const checkResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n            // If check passes, return success\n            if (checkResponse.hasFinancialData) {\n                return {\n                    success: true,\n                    message: checkResponse.diagnosis || \"Document content available for analysis\"\n                };\n            }\n            // If check fails and retry is enabled, try verification endpoint which will accept any content\n            if (retryExtraction) {\n                const verifyResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/verify-financial-data\"), {\n                    retry_extraction: true\n                });\n                return verifyResponse;\n            }\n            // Even if verification fails, we'll still allow using the document\n            // This ensures users can still try to use documents that might not have\n            // ideal structure but could still be useful\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        } catch (error) {\n            console.error(\"Error verifying document:\", error);\n            // Even if verification fails, we'll allow continuing with the document\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        }\n    },\n    /**\n   * Uploads and verifies a document, ensuring it has valid financial data\n   */ async uploadAndVerifyDocument (file) {\n        let autoVerify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        try {\n            // Step 1: Upload the document\n            console.log(\"Uploading document...\");\n            const initialDocument = await this.uploadDocument(file);\n            // Step 2: Poll for document processing completion\n            console.log(\"Polling for document processing completion...\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get a secure URL to access the document\n   */ async getDocumentUrl (documentId) {\n        try {\n            // Instead of using a sample PDF URL which causes CORS issues,\n            // fetch the actual document content as binary data and create a blob URL\n            // Fetch the document content as a blob\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/documents/\").concat(documentId, \"/file\"), {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"application/pdf\"\n                }\n            });\n            // Check if the endpoint exists and returns proper data\n            if (!response.ok) {\n                // If the /file endpoint doesn't exist, we'll try an alternative approach\n                console.warn(\"Document file endpoint returned \".concat(response.status, \", trying alternative approach\"));\n                // Alternative approach: Use the backend API to fetch the document directly\n                // This assumes the backend serves the document content at this endpoint\n                const documentResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId), undefined, {\n                    maxAttempts: 1 // Only try once, don't retry\n                });\n                // If the document has raw_text, we can create a simple PDF from it\n                if (documentResponse.raw_text || documentResponse.extractedData && documentResponse.extractedData.raw_text) {\n                    const text = documentResponse.raw_text || documentResponse.extractedData.raw_text;\n                    // Create a simple PDF from the text using a data URL\n                    // Note: This is a very basic approach for testing\n                    const pdfBlob = new Blob([\n                        text\n                    ], {\n                        type: \"application/pdf\"\n                    });\n                    const url = URL.createObjectURL(pdfBlob);\n                    createdBlobUrls.push(url);\n                    return url;\n                }\n                // If we get here, we couldn't fetch a proper document - show error\n                throw new Error(\"Could not retrieve document file. Backend returned \".concat(response.status));\n            }\n            // Get the PDF data as a blob\n            const blob = await response.blob();\n            // Create a URL for the blob\n            const url = URL.createObjectURL(blob);\n            createdBlobUrls.push(url);\n            return url;\n        } catch (error) {\n            console.error(\"Error creating document URL:\", error);\n            // Fallback to a simple text-based PDF for now\n            // Create a small placeholder PDF with an error message\n            const errorText = \"Error loading document: \".concat(error instanceof Error ? error.message : \"Unknown error\");\n            const pdfBlob = new Blob([\n                errorText\n            ], {\n                type: \"application/pdf\"\n            });\n            const url = URL.createObjectURL(pdfBlob);\n            createdBlobUrls.push(url);\n            return url;\n        }\n    },\n    /**\n   * Get all citations for a document\n   */ async getDocumentCitations (documentId) {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/citations\"));\n            // Ensure the response is an array\n            if (Array.isArray(response)) {\n                // Validate each citation\n                return response.map((citation)=>({\n                        id: citation.id || \"\",\n                        text: citation.text,\n                        documentId: citation.document_id,\n                        highlightId: citation.highlight_id,\n                        page: citation.page,\n                        rects: citation.rects,\n                        messageId: citation.message_id,\n                        analysisId: citation.analysis_id\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error getting document citations:\", error);\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Create a new citation in a document\n   */ async createCitation (documentId, citation) {\n        try {\n            // Convert to snake_case for the API\n            const apiCitation = {\n                text: citation.text,\n                document_id: documentId,\n                highlight_id: citation.highlightId,\n                page: citation.page,\n                rects: citation.rects,\n                message_id: citation.messageId,\n                analysis_id: citation.analysisId\n            };\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/citations\"), apiCitation);\n            // Convert response back to camelCase\n            return {\n                id: response.id || \"\",\n                text: response.text,\n                documentId: response.document_id,\n                highlightId: response.highlight_id,\n                page: response.page,\n                rects: response.rects,\n                messageId: response.message_id,\n                analysisId: response.analysis_id\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Upload a document with progress tracking\n   */ async uploadDocumentWithProgress (file, onProgress) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Use the progress-enabled upload method - using type assertion for schema compatibility\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.uploadWithProgress(\"/api/documents/upload\", formData, onProgress, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // Return placeholder document with the ID\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Uploads and verifies a document with progress tracking,\n   * ensuring it has valid financial data\n   */ async uploadAndVerifyDocumentWithProgress (file, onProgress) {\n        let autoVerify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        try {\n            // Create wrapper for progress that includes the stage\n            const uploadProgressWrapper = onProgress ? (progress)=>onProgress(progress * 0.4, \"Uploading file\") : undefined;\n            // Step 1: Upload the document (40% of total progress)\n            console.log(\"Uploading document...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(0, \"Starting upload\");\n            const initialDocument = await this.uploadDocumentWithProgress(file, uploadProgressWrapper);\n            // Step 2: Poll for document processing completion (40% of total progress)\n            console.log(\"Polling for document processing completion...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(40, \"Processing document\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Update progress during polling\n                if (onProgress) {\n                    const pollingProgress = 40 + Math.min(40, retries / maxRetries * 40);\n                    onProgress(pollingProgress, \"Processing document\");\n                }\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data (20% of total progress)\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(80, \"Verifying financial data\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Enhancing financial data\");\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Retrieving enhanced data\");\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            // Complete the process\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Document ready\");\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQzBDO0FBS1o7QUFFOUIsMERBQTBEO0FBQzFELE1BQU1FLGVBQWVDLHVCQUErQixJQUFJO0FBRXhELHNFQUFzRTtBQUN0RSxNQUFNRyxpQkFBaUIsQ0FBQ0M7SUFDdEJDLFFBQVFELEtBQUssQ0FBQyxjQUFjQTtJQUM1QixJQUFJQSxNQUFNRSxRQUFRLElBQUlGLE1BQU1FLFFBQVEsQ0FBQ0MsSUFBSSxJQUFJSCxNQUFNRSxRQUFRLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxFQUFFO1FBQ3ZFLE1BQU0sSUFBSUMsTUFBTUwsTUFBTUUsUUFBUSxDQUFDQyxJQUFJLENBQUNDLE1BQU07SUFDNUM7SUFDQSxNQUFNLElBQUlDLE1BQU07QUFDbEI7QUEwQ0EsNENBQTRDO0FBQzVDLE1BQU1DLGtCQUE0QixFQUFFO0FBRXBDLHVDQUF1QztBQUNoQyxNQUFNQyxrQkFBa0I7SUFDN0JELGdCQUFnQkUsT0FBTyxDQUFDQyxDQUFBQTtRQUN0QixJQUFJO1lBQ0ZDLElBQUlDLGVBQWUsQ0FBQ0Y7UUFDdEIsRUFBRSxPQUFPRyxHQUFHO1lBQ1ZYLFFBQVFELEtBQUssQ0FBQyx1QkFBdUJZO1FBQ3ZDO0lBQ0Y7SUFDQU4sZ0JBQWdCTyxNQUFNLEdBQUcsR0FBRyxrQkFBa0I7QUFDaEQsRUFBRTtBQUVLLE1BQU1DLGVBQWU7SUFDMUI7O0dBRUMsR0FDRCxNQUFNQyxnQkFBZUMsSUFBVTtRQUM3QixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxJQUFJQztZQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFIO1lBRXhCLHVEQUF1RDtZQUN2RCxNQUFNYixPQUFPLE1BQU1WLG1EQUFVQSxDQUFDMkIsWUFBWSxDQUN4Qyx5QkFDQUgsVUFDQXZCLDZFQUE0QkE7WUFHOUIsa0ZBQWtGO1lBQ2xGLE9BQU87Z0JBQ0wyQixVQUFVO29CQUNSQyxJQUFJbkIsS0FBS29CLFdBQVc7b0JB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LElBQUlQLFNBQVMvQixXQUFXO2dDQUNsRkcsZUFBZWxDLFNBQVNrQyxhQUFhLElBQUlsQyxTQUFTc0UsY0FBYyxJQUFJUixTQUFTNUIsYUFBYTtnQ0FDMUZELFNBQVNqQyxTQUFTaUMsT0FBTyxJQUFJNkIsU0FBUzdCLE9BQU87Z0NBQzdDRSxpQkFBaUJuQyxTQUFTbUMsZUFBZSxJQUFJbkMsU0FBU3VFLGdCQUFnQixJQUFJVCxTQUFTM0IsZUFBZTs0QkFDcEc7d0JBQ0Y7b0JBQ0YsT0FBTzt3QkFDTHBDLFFBQVE2RCxHQUFHLENBQUM7b0JBQ2Q7Z0JBQ0YsRUFBRSxPQUFPOUQsT0FBTztvQkFDZEMsUUFBUUQsS0FBSyxDQUFDLDZDQUE2Q0E7Z0JBQzNELHNDQUFzQztnQkFDeEM7WUFDRjtZQUVBLHVCQUF1QjtZQUN2QjRHLHVCQUFBQSxpQ0FBQUEsV0FBYSxLQUFLO1lBQ2xCLE9BQU81QztRQUNULEVBQUUsT0FBT2hFLE9BQU87WUFDZCxNQUFNRCxlQUFlQztRQUN2QjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS9kb2N1bWVudHMudHM/ZWQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9jZXNzZWREb2N1bWVudCwgRG9jdW1lbnRVcGxvYWRSZXNwb25zZSwgQ2l0YXRpb24gfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICcuL2FwaVNlcnZpY2UnO1xuaW1wb3J0IHsgXG4gIERvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEsIFxuICBQcm9jZXNzZWREb2N1bWVudFNjaGVtYSxcbiAgQ2l0YXRpb25TY2hlbWFcbn0gZnJvbSAnQC92YWxpZGF0aW9uL3NjaGVtYXMnO1xuXG4vLyBBUEkgYmFzZSBVUkwgLSB3b3VsZCBiZSBjb25maWd1cmVkIGJhc2VkIG9uIGVudmlyb25tZW50XG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuXG4vLyBGdW5jdGlvbiB0byBoYW5kbGUgQVBJIGVycm9ycyAtIGtlZXBpbmcgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvcjogYW55KTogbmV2ZXIgPT4ge1xuICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2UuZGF0YSAmJiBlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggdGhlIHNlcnZlcicpO1xufTtcblxuLy8gRGVmaW5lIHJlc3BvbnNlIHR5cGVzIGZvciBiZXR0ZXIgdHlwZSBzYWZldHlcbmludGVyZmFjZSBEb2N1bWVudENvdW50UmVzcG9uc2Uge1xuICBjb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRSZXNwb25zZSBleHRlbmRzIFByb2Nlc3NlZERvY3VtZW50IHtcbiAgLy8gU3VwcG9ydCBzbmFrZV9jYXNlIGJhY2tlbmQgZm9ybWF0XG4gIHByb2Nlc3Npbmdfc3RhdHVzPzogc3RyaW5nO1xuICBjb250ZW50X3R5cGU/OiBzdHJpbmc7XG4gIGV4dHJhY3RlZF9kYXRhPzogYW55O1xuICBjb25maWRlbmNlX3Njb3JlPzogbnVtYmVyO1xuICBlcnJvcl9tZXNzYWdlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRVcmxSZXNwb25zZSB7XG4gIHVybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2Uge1xuICBoYXNGaW5hbmNpYWxEYXRhOiBib29sZWFuO1xuICBkaWFnbm9zaXM6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuLy8gQVBJIGNpdGF0aW9uIGZvcm1hdCAoZm9yIHJlcXVlc3QvcmVzcG9uc2UgdG8vZnJvbSBiYWNrZW5kKVxuaW50ZXJmYWNlIEFwaUNpdGF0aW9uIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgZG9jdW1lbnRfaWQ6IHN0cmluZztcbiAgaGlnaGxpZ2h0X2lkPzogc3RyaW5nO1xuICBwYWdlOiBudW1iZXI7XG4gIHJlY3RzOiBhbnlbXTtcbiAgbWVzc2FnZV9pZD86IHN0cmluZztcbiAgYW5hbHlzaXNfaWQ/OiBzdHJpbmc7XG59XG5cbi8vIFN0b3JlIGNyZWF0ZWQgYmxvYiBVUkxzIGZvciBsYXRlciBjbGVhbnVwXG5jb25zdCBjcmVhdGVkQmxvYlVybHM6IHN0cmluZ1tdID0gW107XG5cbi8vIEFkZCBhIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGJsb2IgVVJMc1xuZXhwb3J0IGNvbnN0IGNsZWFudXBCbG9iVXJscyA9ICgpID0+IHtcbiAgY3JlYXRlZEJsb2JVcmxzLmZvckVhY2godXJsID0+IHtcbiAgICB0cnkge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJldm9raW5nIFVSTDonLCBlKTtcbiAgICB9XG4gIH0pO1xuICBjcmVhdGVkQmxvYlVybHMubGVuZ3RoID0gMDsgLy8gQ2xlYXIgdGhlIGFycmF5XG59O1xuXG5leHBvcnQgY29uc3QgZG9jdW1lbnRzQXBpID0ge1xuICAvKipcbiAgICogVXBsb2FkcyBhIGRvY3VtZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIHVwbG9hZERvY3VtZW50KGZpbGU6IEZpbGUpOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gVHlwZSBhc3NlcnRpb24gdG8gcmVzb2x2ZSBzY2hlbWEgY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFwaVNlcnZpY2UucG9zdEZvcm1EYXRhPERvY3VtZW50VXBsb2FkUmVzcG9uc2U+KFxuICAgICAgICAnL2FwaS9kb2N1bWVudHMvdXBsb2FkJyxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIERvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEgYXMgYW55XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGb3Igbm93LCByZXR1cm4gYSBwbGFjZWhvbGRlciBQcm9jZXNzZWREb2N1bWVudCB1bnRpbCByZS1wcm9jZXNzaW5nIGlzIGNvbXBsZXRlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlkOiBkYXRhLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGZpbGVuYW1lOiBkYXRhLmZpbGVuYW1lLFxuICAgICAgICAgIHVwbG9hZFRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGZpbGVTaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICB1c2VySWQ6ICdjdXJyZW50LXVzZXInLCAvLyBXb3VsZCBjb21lIGZyb20gYXV0aCBpbiBhIHJlYWwgYXBwXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnb3RoZXInLFxuICAgICAgICBleHRyYWN0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHBlcmlvZHM6IFtdLFxuICAgICAgICBleHRyYWN0ZWREYXRhOiB7fSxcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiAwLFxuICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBkYXRhLnN0YXR1cyA9PT0gJ2ZhaWxlZCcgPyBkYXRhLm1lc3NhZ2UgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkb2N1bWVudHNcbiAgICovXG4gIGFzeW5jIGxpc3REb2N1bWVudHMocGFnZTogbnVtYmVyID0gMSwgcGFnZVNpemU6IG51bWJlciA9IDEwKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpU2VydmljZS5nZXQoYC9hcGkvZG9jdW1lbnRzP3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZXRzIGRvY3VtZW50IGNvdW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudENvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRDb3VudFJlc3BvbnNlPignL2FwaS9kb2N1bWVudHMvY291bnQnKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5jb3VudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBkb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIGNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8RmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGFwaVNlcnZpY2UuZ2V0PEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaGVjay1maW5hbmNpYWwtZGF0YWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFZlcmlmeSBhIGRvY3VtZW50J3MgZmluYW5jaWFsIGRhdGEgYW5kIG9wdGlvbmFsbHkgdHJpZ2dlciByZS1leHRyYWN0aW9uXG4gICAqL1xuICBhc3luYyB2ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnRJZDogc3RyaW5nLCByZXRyeUV4dHJhY3Rpb246IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8RmluYW5jaWFsRGF0YVZlcmlmeVJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRvY3VtZW50IGhhcyBmaW5hbmNpYWwgZGF0YVxuICAgICAgY29uc3QgY2hlY2tSZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaGVjay1maW5hbmNpYWwtZGF0YWApO1xuICAgICAgXG4gICAgICAvLyBJZiBjaGVjayBwYXNzZXMsIHJldHVybiBzdWNjZXNzXG4gICAgICBpZiAoY2hlY2tSZXNwb25zZS5oYXNGaW5hbmNpYWxEYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVja1Jlc3BvbnNlLmRpYWdub3NpcyB8fCBcIkRvY3VtZW50IGNvbnRlbnQgYXZhaWxhYmxlIGZvciBhbmFseXNpc1wiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGNoZWNrIGZhaWxzIGFuZCByZXRyeSBpcyBlbmFibGVkLCB0cnkgdmVyaWZpY2F0aW9uIGVuZHBvaW50IHdoaWNoIHdpbGwgYWNjZXB0IGFueSBjb250ZW50XG4gICAgICBpZiAocmV0cnlFeHRyYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5wb3N0PEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZT4oXG4gICAgICAgICAgYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vdmVyaWZ5LWZpbmFuY2lhbC1kYXRhYCxcbiAgICAgICAgICB7IHJldHJ5X2V4dHJhY3Rpb246IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdmVyaWZ5UmVzcG9uc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzLCB3ZSdsbCBzdGlsbCBhbGxvdyB1c2luZyB0aGUgZG9jdW1lbnRcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB1c2VycyBjYW4gc3RpbGwgdHJ5IHRvIHVzZSBkb2N1bWVudHMgdGhhdCBtaWdodCBub3QgaGF2ZVxuICAgICAgLy8gaWRlYWwgc3RydWN0dXJlIGJ1dCBjb3VsZCBzdGlsbCBiZSB1c2VmdWxcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIC8vIEZvcmNlIHN1Y2Nlc3MgdG8gYWxsb3cgZG9jdW1lbnQgdXNlIHJlZ2FyZGxlc3Mgb2YgY29udGVudFxuICAgICAgICBtZXNzYWdlOiBcIkRvY3VtZW50IGF2YWlsYWJsZSBmb3IgYW5hbHlzaXMgKHZlcmlmaWNhdGlvbiBieXBhc3NlZClcIlxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHZlcmlmeWluZyBkb2N1bWVudDpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBFdmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlscywgd2UnbGwgYWxsb3cgY29udGludWluZyB3aXRoIHRoZSBkb2N1bWVudFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSwgLy8gRm9yY2Ugc3VjY2VzcyB0byBhbGxvdyBkb2N1bWVudCB1c2VcbiAgICAgICAgbWVzc2FnZTogXCJEb2N1bWVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzICh2ZXJpZmljYXRpb24gYnlwYXNzZWQpXCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFVwbG9hZHMgYW5kIHZlcmlmaWVzIGEgZG9jdW1lbnQsIGVuc3VyaW5nIGl0IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YVxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnQoXG4gICAgZmlsZTogRmlsZSwgXG4gICAgYXV0b1ZlcmlmeTogYm9vbGVhbiA9IHRydWVcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IFVwbG9hZCB0aGUgZG9jdW1lbnRcbiAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRpbmcgZG9jdW1lbnQuLi4nKTtcbiAgICAgIGNvbnN0IGluaXRpYWxEb2N1bWVudCA9IGF3YWl0IHRoaXMudXBsb2FkRG9jdW1lbnQoZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMjogUG9sbCBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uXG4gICAgICBjb25zb2xlLmxvZygnUG9sbGluZyBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uLi4uJyk7XG4gICAgICBsZXQgZG9jdW1lbnQgPSBpbml0aWFsRG9jdW1lbnQ7XG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMzA7IC8vIDMwICogMiBzZWNvbmRzID0gMSBtaW51dGUgbWF4XG4gICAgICBcbiAgICAgIHdoaWxlIChyZXRyaWVzIDwgbWF4UmV0cmllcyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnZmFpbGVkJykge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpOyAvLyBXYWl0IDIgc2Vjb25kc1xuICAgICAgICBcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGRvY3VtZW50J3MgY3VycmVudCBzdGF0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGRvY3VtZW50IHdpdGggdGhlIGxhdGVzdCBkYXRhXG4gICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IHJlc3BvbnNlLnByb2Nlc3NpbmdTdGF0dXMgfHwgcmVzcG9uc2UucHJvY2Vzc2luZ19zdGF0dXMgfHwgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSB8fCByZXNwb25zZS5jb250ZW50X3R5cGUgfHwgZG9jdW1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHJlc3BvbnNlLmNvbmZpZGVuY2VTY29yZSB8fCByZXNwb25zZS5jb25maWRlbmNlX3Njb3JlIHx8IGRvY3VtZW50LmNvbmZpZGVuY2VTY29yZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogcmVzcG9uc2UuZXJyb3JNZXNzYWdlIHx8IHJlc3BvbnNlLmVycm9yX21lc3NhZ2UgfHwgZG9jdW1lbnQuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRG9jdW1lbnQgc3RhdHVzIGFmdGVyIGF0dGVtcHQgJHtyZXRyaWVzICsgMX06ICR7ZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1c31gKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9jdW1lbnQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7ZG9jdW1lbnQuZXJyb3JNZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcG9sbGluZyBkb2N1bWVudCBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRyeWluZyBldmVuIGlmIGFuIGluZGl2aWR1YWwgcG9sbCBmYWlsc1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXRyaWVzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHByb2Nlc3NpbmcgdGltZWQgb3V0IG9yIGZhaWxlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGVwIDM6IElmIGF1dG8tdmVyaWZ5IGlzIGVuYWJsZWQsIGNoZWNrIGFuZCBwb3RlbnRpYWxseSBlbmhhbmNlIGZpbmFuY2lhbCBkYXRhXG4gICAgICBpZiAoYXV0b1ZlcmlmeSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGZpbmFuY2lhbCBkYXRhLi4uJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0Lmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBuZWVkcyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgY2hlY2tSZXN1bHQuZGlhZ25vc2lzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZmluYW5jaWFsIGRhdGEgaXMgbWlzc2luZyBvciBpbnN1ZmZpY2llbnQsIHRyeSB0byB2ZXJpZnkgYW5kIGVuaGFuY2UgaXRcbiAgICAgICAgICAgIGNvbnN0IHZlcmlmeVJlc3VsdCA9IGF3YWl0IHRoaXMudmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb24gcmVzdWx0OicsIHZlcmlmeVJlc3VsdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2ZXJpZnlSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAvLyBSZS1mZXRjaCB0aGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSBlbmhhbmNlZCBkYXRhXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkb2N1bWVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZERhdGE6IHJlc3BvbnNlLmV4dHJhY3RlZERhdGEgfHwgcmVzcG9uc2UuZXh0cmFjdGVkX2RhdGEgfHwgZG9jdW1lbnQuZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlsc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzZWN1cmUgVVJMIHRvIGFjY2VzcyB0aGUgZG9jdW1lbnRcbiAgICovXG4gIGFzeW5jIGdldERvY3VtZW50VXJsKGRvY3VtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEluc3RlYWQgb2YgdXNpbmcgYSBzYW1wbGUgUERGIFVSTCB3aGljaCBjYXVzZXMgQ09SUyBpc3N1ZXMsXG4gICAgICAvLyBmZXRjaCB0aGUgYWN0dWFsIGRvY3VtZW50IGNvbnRlbnQgYXMgYmluYXJ5IGRhdGEgYW5kIGNyZWF0ZSBhIGJsb2IgVVJMXG4gICAgICBcbiAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCBjb250ZW50IGFzIGEgYmxvYlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9maWxlYCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBlbmRwb2ludCBleGlzdHMgYW5kIHJldHVybnMgcHJvcGVyIGRhdGFcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gSWYgdGhlIC9maWxlIGVuZHBvaW50IGRvZXNuJ3QgZXhpc3QsIHdlJ2xsIHRyeSBhbiBhbHRlcm5hdGl2ZSBhcHByb2FjaFxuICAgICAgICBjb25zb2xlLndhcm4oYERvY3VtZW50IGZpbGUgZW5kcG9pbnQgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9LCB0cnlpbmcgYWx0ZXJuYXRpdmUgYXBwcm9hY2hgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsdGVybmF0aXZlIGFwcHJvYWNoOiBVc2UgdGhlIGJhY2tlbmQgQVBJIHRvIGZldGNoIHRoZSBkb2N1bWVudCBkaXJlY3RseVxuICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGJhY2tlbmQgc2VydmVzIHRoZSBkb2N1bWVudCBjb250ZW50IGF0IHRoaXMgZW5kcG9pbnRcbiAgICAgICAgY29uc3QgZG9jdW1lbnRSZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9YCwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgbWF4QXR0ZW1wdHM6IDEgLy8gT25seSB0cnkgb25jZSwgZG9uJ3QgcmV0cnlcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgaGFzIHJhd190ZXh0LCB3ZSBjYW4gY3JlYXRlIGEgc2ltcGxlIFBERiBmcm9tIGl0XG4gICAgICAgIGlmIChkb2N1bWVudFJlc3BvbnNlLnJhd190ZXh0IHx8IChkb2N1bWVudFJlc3BvbnNlLmV4dHJhY3RlZERhdGEgJiYgZG9jdW1lbnRSZXNwb25zZS5leHRyYWN0ZWREYXRhLnJhd190ZXh0KSkge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudFJlc3BvbnNlLnJhd190ZXh0IHx8IGRvY3VtZW50UmVzcG9uc2UuZXh0cmFjdGVkRGF0YS5yYXdfdGV4dDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgUERGIGZyb20gdGhlIHRleHQgdXNpbmcgYSBkYXRhIFVSTFxuICAgICAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIGFwcHJvYWNoIGZvciB0ZXN0aW5nXG4gICAgICAgICAgY29uc3QgcGRmQmxvYiA9IG5ldyBCbG9iKFt0ZXh0XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vcGRmJyB9KTtcbiAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHBkZkJsb2IpO1xuICAgICAgICAgIGNyZWF0ZWRCbG9iVXJscy5wdXNoKHVybCk7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHdlIGNvdWxkbid0IGZldGNoIGEgcHJvcGVyIGRvY3VtZW50IC0gc2hvdyBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSBkb2N1bWVudCBmaWxlLiBCYWNrZW5kIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIFBERiBkYXRhIGFzIGEgYmxvYlxuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgVVJMIGZvciB0aGUgYmxvYlxuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIGNyZWF0ZWRCbG9iVXJscy5wdXNoKHVybCk7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgZG9jdW1lbnQgVVJMOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGEgc2ltcGxlIHRleHQtYmFzZWQgUERGIGZvciBub3dcbiAgICAgIC8vIENyZWF0ZSBhIHNtYWxsIHBsYWNlaG9sZGVyIFBERiB3aXRoIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGBFcnJvciBsb2FkaW5nIGRvY3VtZW50OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWA7XG4gICAgICBjb25zdCBwZGZCbG9iID0gbmV3IEJsb2IoW2Vycm9yVGV4dF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSk7XG4gICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHBkZkJsb2IpO1xuICAgICAgY3JlYXRlZEJsb2JVcmxzLnB1c2godXJsKTtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldCBhbGwgY2l0YXRpb25zIGZvciBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudENpdGF0aW9ucyhkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPENpdGF0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxBcGlDaXRhdGlvbltdPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSByZXNwb25zZSBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGVhY2ggY2l0YXRpb25cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChjaXRhdGlvbiA9PiAoe1xuICAgICAgICAgIGlkOiBjaXRhdGlvbi5pZCB8fCAnJyxcbiAgICAgICAgICB0ZXh0OiBjaXRhdGlvbi50ZXh0LFxuICAgICAgICAgIGRvY3VtZW50SWQ6IGNpdGF0aW9uLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGhpZ2hsaWdodElkOiBjaXRhdGlvbi5oaWdobGlnaHRfaWQsXG4gICAgICAgICAgcGFnZTogY2l0YXRpb24ucGFnZSxcbiAgICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgICAgbWVzc2FnZUlkOiBjaXRhdGlvbi5tZXNzYWdlX2lkLFxuICAgICAgICAgIGFuYWx5c2lzSWQ6IGNpdGF0aW9uLmFuYWx5c2lzX2lkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGRvY3VtZW50IGNpdGF0aW9uczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjaXRhdGlvbiBpbiBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBjcmVhdGVDaXRhdGlvbihkb2N1bWVudElkOiBzdHJpbmcsIGNpdGF0aW9uOiBPbWl0PENpdGF0aW9uLCAnaWQnPik6IFByb21pc2U8Q2l0YXRpb24+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCB0byBzbmFrZV9jYXNlIGZvciB0aGUgQVBJXG4gICAgICBjb25zdCBhcGlDaXRhdGlvbjogQXBpQ2l0YXRpb24gPSB7XG4gICAgICAgIHRleHQ6IGNpdGF0aW9uLnRleHQsXG4gICAgICAgIGRvY3VtZW50X2lkOiBkb2N1bWVudElkLFxuICAgICAgICBoaWdobGlnaHRfaWQ6IGNpdGF0aW9uLmhpZ2hsaWdodElkLFxuICAgICAgICBwYWdlOiBjaXRhdGlvbi5wYWdlLFxuICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgIG1lc3NhZ2VfaWQ6IGNpdGF0aW9uLm1lc3NhZ2VJZCxcbiAgICAgICAgYW5hbHlzaXNfaWQ6IGNpdGF0aW9uLmFuYWx5c2lzSWRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5wb3N0PEFwaUNpdGF0aW9uPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgLCBhcGlDaXRhdGlvbik7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgYmFjayB0byBjYW1lbENhc2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXNwb25zZS5pZCB8fCAnJyxcbiAgICAgICAgdGV4dDogcmVzcG9uc2UudGV4dCxcbiAgICAgICAgZG9jdW1lbnRJZDogcmVzcG9uc2UuZG9jdW1lbnRfaWQsXG4gICAgICAgIGhpZ2hsaWdodElkOiByZXNwb25zZS5oaWdobGlnaHRfaWQsXG4gICAgICAgIHBhZ2U6IHJlc3BvbnNlLnBhZ2UsXG4gICAgICAgIHJlY3RzOiByZXNwb25zZS5yZWN0cyxcbiAgICAgICAgbWVzc2FnZUlkOiByZXNwb25zZS5tZXNzYWdlX2lkLFxuICAgICAgICBhbmFseXNpc0lkOiByZXNwb25zZS5hbmFseXNpc19pZFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gICAqL1xuICBhc3luYyB1cGxvYWREb2N1bWVudFdpdGhQcm9ncmVzcyhcbiAgICBmaWxlOiBGaWxlLCBcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgcHJvZ3Jlc3MtZW5hYmxlZCB1cGxvYWQgbWV0aG9kIC0gdXNpbmcgdHlwZSBhc3NlcnRpb24gZm9yIHNjaGVtYSBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpU2VydmljZS51cGxvYWRXaXRoUHJvZ3Jlc3M8RG9jdW1lbnRVcGxvYWRSZXNwb25zZT4oXG4gICAgICAgICcvYXBpL2RvY3VtZW50cy91cGxvYWQnLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSBhcyBhbnlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBwbGFjZWhvbGRlciBkb2N1bWVudCB3aXRoIHRoZSBJRFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpZDogZGF0YS5kb2N1bWVudF9pZCxcbiAgICAgICAgICBmaWxlbmFtZTogZGF0YS5maWxlbmFtZSxcbiAgICAgICAgICB1cGxvYWRUaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgdXNlcklkOiAnY3VycmVudC11c2VyJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudFR5cGU6ICdvdGhlcicsXG4gICAgICAgIGV4dHJhY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGVyaW9kczogW10sXG4gICAgICAgIGV4dHJhY3RlZERhdGE6IHt9LFxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IDAsXG4gICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGRhdGEuc3RhdHVzID09PSAnZmFpbGVkJyA/IGRhdGEubWVzc2FnZSA6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVXBsb2FkcyBhbmQgdmVyaWZpZXMgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nLFxuICAgKiBlbnN1cmluZyBpdCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFZlcmlmeURvY3VtZW50V2l0aFByb2dyZXNzKFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlciwgc3RhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgICBhdXRvVmVyaWZ5OiBib29sZWFuID0gdHJ1ZVxuICApOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB3cmFwcGVyIGZvciBwcm9ncmVzcyB0aGF0IGluY2x1ZGVzIHRoZSBzdGFnZVxuICAgICAgY29uc3QgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyID0gb25Qcm9ncmVzcyBcbiAgICAgICAgPyAocHJvZ3Jlc3M6IG51bWJlcikgPT4gb25Qcm9ncmVzcyhwcm9ncmVzcyAqIDAuNCwgJ1VwbG9hZGluZyBmaWxlJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMTogVXBsb2FkIHRoZSBkb2N1bWVudCAoNDAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1VwbG9hZGluZyBkb2N1bWVudC4uLicpO1xuICAgICAgb25Qcm9ncmVzcz8uKDAsICdTdGFydGluZyB1cGxvYWQnKTtcbiAgICAgIGNvbnN0IGluaXRpYWxEb2N1bWVudCA9IGF3YWl0IHRoaXMudXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MoZmlsZSwgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyKTtcbiAgICAgIFxuICAgICAgLy8gU3RlcCAyOiBQb2xsIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24gKDQwJSBvZiB0b3RhbCBwcm9ncmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdQb2xsaW5nIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24uLi4nKTtcbiAgICAgIG9uUHJvZ3Jlc3M/Lig0MCwgJ1Byb2Nlc3NpbmcgZG9jdW1lbnQnKTtcbiAgICAgIFxuICAgICAgbGV0IGRvY3VtZW50ID0gaW5pdGlhbERvY3VtZW50O1xuICAgICAgbGV0IHJldHJpZXMgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDMwOyAvLyAzMCAqIDIgc2Vjb25kcyA9IDEgbWludXRlIG1heFxuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTsgLy8gV2FpdCAyIHNlY29uZHNcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBkdXJpbmcgcG9sbGluZ1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGNvbnN0IHBvbGxpbmdQcm9ncmVzcyA9IDQwICsgTWF0aC5taW4oNDAsIChyZXRyaWVzIC8gbWF4UmV0cmllcykgKiA0MCk7XG4gICAgICAgICAgb25Qcm9ncmVzcyhwb2xsaW5nUHJvZ3Jlc3MsICdQcm9jZXNzaW5nIGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCdzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBkb2N1bWVudCB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiByZXNwb25zZS5wcm9jZXNzaW5nU3RhdHVzIHx8IHJlc3BvbnNlLnByb2Nlc3Npbmdfc3RhdHVzIHx8IGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yTWVzc2FnZSB8fCByZXNwb25zZS5lcnJvcl9tZXNzYWdlIHx8IGRvY3VtZW50LmVycm9yTWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50IHN0YXR1cyBhZnRlciBhdHRlbXB0ICR7cmV0cmllcyArIDF9OiAke2RvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXN9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2RvY3VtZW50LmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvbGxpbmcgZG9jdW1lbnQgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cnlpbmcgZXZlbiBpZiBhbiBpbmRpdmlkdWFsIHBvbGwgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RlcCAzOiBJZiBhdXRvLXZlcmlmeSBpcyBlbmFibGVkLCBjaGVjayBhbmQgcG90ZW50aWFsbHkgZW5oYW5jZSBmaW5hbmNpYWwgZGF0YSAoMjAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgaWYgKGF1dG9WZXJpZnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YS4uLicpO1xuICAgICAgICBvblByb2dyZXNzPy4oODAsICdWZXJpZnlpbmcgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0Lmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBuZWVkcyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgY2hlY2tSZXN1bHQuZGlhZ25vc2lzKTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig4NSwgJ0VuaGFuY2luZyBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBmaW5hbmNpYWwgZGF0YSBpcyBtaXNzaW5nIG9yIGluc3VmZmljaWVudCwgdHJ5IHRvIHZlcmlmeSBhbmQgZW5oYW5jZSBpdFxuICAgICAgICAgICAgY29uc3QgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbiByZXN1bHQ6JywgdmVyaWZ5UmVzdWx0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlcmlmeVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig5MCwgJ1JldHJpZXZpbmcgZW5oYW5jZWQgZGF0YScpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGRvY3VtZW50IHRvIGdldCB0aGUgZW5oYW5jZWQgZGF0YVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb21wbGV0ZSB0aGUgcHJvY2Vzc1xuICAgICAgb25Qcm9ncmVzcz8uKDEwMCwgJ0RvY3VtZW50IHJlYWR5Jyk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbImFwaVNlcnZpY2UiLCJEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJoYW5kbGVBcGlFcnJvciIsImVycm9yIiwiY29uc29sZSIsInJlc3BvbnNlIiwiZGF0YSIsImRldGFpbCIsIkVycm9yIiwiY3JlYXRlZEJsb2JVcmxzIiwiY2xlYW51cEJsb2JVcmxzIiwiZm9yRWFjaCIsInVybCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsImUiLCJsZW5ndGgiLCJkb2N1bWVudHNBcGkiLCJ1cGxvYWREb2N1bWVudCIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicG9zdEZvcm1EYXRhIiwibWV0YWRhdGEiLCJpZCIsImRvY3VtZW50X2lkIiwiZmlsZW5hbWUiLCJ1cGxvYWRUaW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmaWxlU2l6ZSIsInNpemUiLCJtaW1lVHlwZSIsInR5cGUiLCJ1c2VySWQiLCJjb250ZW50VHlwZSIsImV4dHJhY3Rpb25UaW1lc3RhbXAiLCJwZXJpb2RzIiwiZXh0cmFjdGVkRGF0YSIsImNvbmZpZGVuY2VTY29yZSIsInByb2Nlc3NpbmdTdGF0dXMiLCJzdGF0dXMiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwibGlzdERvY3VtZW50cyIsInBhZ2UiLCJwYWdlU2l6ZSIsImdldCIsImdldERvY3VtZW50Q291bnQiLCJjb3VudCIsImNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhIiwiZG9jdW1lbnRJZCIsInZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YSIsInJldHJ5RXh0cmFjdGlvbiIsImNoZWNrUmVzcG9uc2UiLCJoYXNGaW5hbmNpYWxEYXRhIiwic3VjY2VzcyIsImRpYWdub3NpcyIsInZlcmlmeVJlc3BvbnNlIiwicG9zdCIsInJldHJ5X2V4dHJhY3Rpb24iLCJ1cGxvYWRBbmRWZXJpZnlEb2N1bWVudCIsImF1dG9WZXJpZnkiLCJsb2ciLCJpbml0aWFsRG9jdW1lbnQiLCJkb2N1bWVudCIsInJldHJpZXMiLCJtYXhSZXRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc2luZ19zdGF0dXMiLCJjb250ZW50X3R5cGUiLCJleHRyYWN0ZWRfZGF0YSIsImNvbmZpZGVuY2Vfc2NvcmUiLCJlcnJvcl9tZXNzYWdlIiwiY2hlY2tSZXN1bHQiLCJ2ZXJpZnlSZXN1bHQiLCJnZXREb2N1bWVudFVybCIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIm9rIiwid2FybiIsImRvY3VtZW50UmVzcG9uc2UiLCJtYXhBdHRlbXB0cyIsInJhd190ZXh0IiwidGV4dCIsInBkZkJsb2IiLCJCbG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwicHVzaCIsImJsb2IiLCJlcnJvclRleHQiLCJnZXREb2N1bWVudENpdGF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImNpdGF0aW9uIiwiaGlnaGxpZ2h0SWQiLCJoaWdobGlnaHRfaWQiLCJyZWN0cyIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJhbmFseXNpc0lkIiwiYW5hbHlzaXNfaWQiLCJjcmVhdGVDaXRhdGlvbiIsImFwaUNpdGF0aW9uIiwidXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwidXBsb2FkV2l0aFByb2dyZXNzIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJ1cGxvYWRQcm9ncmVzc1dyYXBwZXIiLCJwcm9ncmVzcyIsInBvbGxpbmdQcm9ncmVzcyIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/documents.ts\n"));

/***/ })

});