"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/page",{

/***/ "(app-pages-browser)/./src/lib/api/documents.ts":
/*!**********************************!*\
  !*** ./src/lib/api/documents.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   documentsApi: function() { return /* binding */ documentsApi; }\n/* harmony export */ });\n/* harmony import */ var _apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiService */ \"(app-pages-browser)/./src/lib/api/apiService.ts\");\n/* harmony import */ var _validation_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/validation/schemas */ \"(app-pages-browser)/./src/validation/schemas.ts\");\n\n\n// Function to handle API errors - keeping for backwards compatibility\nconst handleApiError = (error)=>{\n    console.error(\"API Error:\", error);\n    if (error.response && error.response.data && error.response.data.detail) {\n        throw new Error(error.response.data.detail);\n    }\n    throw new Error(\"An error occurred while communicating with the server\");\n};\nconst documentsApi = {\n    /**\n   * Uploads a document to the server\n   */ async uploadDocument (file) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Type assertion to resolve schema compatibility issue\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.postFormData(\"/api/documents/upload\", formData, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // For now, return a placeholder ProcessedDocument until re-processing is complete\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Lists all documents\n   */ async listDocuments () {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents?page=\".concat(page, \"&page_size=\").concat(pageSize));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Gets document count\n   */ async getDocumentCount () {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/count\");\n            return response.count;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Checks if a document has valid financial data\n   */ async checkDocumentFinancialData (documentId) {\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Verify a document's financial data and optionally trigger re-extraction\n   */ async verifyDocumentFinancialData (documentId) {\n        let retryExtraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // First check if document has financial data\n            const checkResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n            // If check passes, return success\n            if (checkResponse.hasFinancialData) {\n                return {\n                    success: true,\n                    message: checkResponse.diagnosis || \"Document content available for analysis\"\n                };\n            }\n            // If check fails and retry is enabled, try verification endpoint which will accept any content\n            if (retryExtraction) {\n                const verifyResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/verify-financial-data\"), {\n                    retry_extraction: true\n                });\n                return verifyResponse;\n            }\n            // Even if verification fails, we'll still allow using the document\n            // This ensures users can still try to use documents that might not have\n            // ideal structure but could still be useful\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        } catch (error) {\n            console.error(\"Error verifying document:\", error);\n            // Even if verification fails, we'll allow continuing with the document\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        }\n    },\n    /**\n   * Uploads and verifies a document, ensuring it has valid financial data\n   */ async uploadAndVerifyDocument (file) {\n        let autoVerify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        try {\n            // Step 1: Upload the document\n            console.log(\"Uploading document...\");\n            const initialDocument = await this.uploadDocument(file);\n            // Step 2: Poll for document processing completion\n            console.log(\"Polling for document processing completion...\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get a secure URL to access the document\n   */ async getDocumentUrl (documentId) {\n        try {\n            // Instead of using a sample PDF URL which causes CORS issues,\n            // fetch the actual document content as binary data and create a blob URL\n            // Fetch the document content as a blob\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/documents/\").concat(documentId, \"/file\"), {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"application/pdf\"\n                }\n            });\n            // Check if the endpoint exists and returns proper data\n            if (!response.ok) {\n                // If the /file endpoint doesn't exist, we'll try an alternative approach\n                console.warn(\"Document file endpoint returned \".concat(response.status, \", trying alternative approach\"));\n                // Alternative approach: Use the backend API to fetch the document directly\n                // This assumes the backend serves the document content at this endpoint\n                const documentResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId), undefined, {\n                    maxAttempts: 1 // Only try once, don't retry\n                });\n                // If the document has raw_text, we can create a simple PDF from it\n                if (documentResponse.raw_text || documentResponse.extractedData && documentResponse.extractedData.raw_text) {\n                    const text = documentResponse.raw_text || documentResponse.extractedData.raw_text;\n                    // Create a simple PDF from the text using a data URL\n                    // Note: This is a very basic approach for testing\n                    const pdfBlob = new Blob([\n                        text\n                    ], {\n                        type: \"application/pdf\"\n                    });\n                    return URL.createObjectURL(pdfBlob);\n                }\n                // If we get here, we couldn't fetch a proper document - show error\n                throw new Error(\"Could not retrieve document file. Backend returned \".concat(response.status));\n            }\n            // Get the PDF data as a blob\n            const blob = await response.blob();\n            // Create a URL for the blob\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error creating document URL:\", error);\n            // Fallback to a simple text-based PDF for now\n            // Create a small placeholder PDF with an error message\n            const errorText = \"Error loading document: \".concat(error instanceof Error ? error.message : \"Unknown error\");\n            const pdfBlob = new Blob([\n                errorText\n            ], {\n                type: \"application/pdf\"\n            });\n            return URL.createObjectURL(pdfBlob);\n        }\n    },\n    /**\n   * Get all citations for a document\n   */ async getDocumentCitations (documentId) {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/citations\"));\n            // Ensure the response is an array\n            if (Array.isArray(response)) {\n                // Validate each citation\n                return response.map((citation)=>({\n                        id: citation.id || \"\",\n                        text: citation.text,\n                        documentId: citation.document_id,\n                        highlightId: citation.highlight_id,\n                        page: citation.page,\n                        rects: citation.rects,\n                        messageId: citation.message_id,\n                        analysisId: citation.analysis_id\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error getting document citations:\", error);\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Create a new citation in a document\n   */ async createCitation (documentId, citation) {\n        try {\n            // Convert to snake_case for the API\n            const apiCitation = {\n                text: citation.text,\n                document_id: documentId,\n                highlight_id: citation.highlightId,\n                page: citation.page,\n                rects: citation.rects,\n                message_id: citation.messageId,\n                analysis_id: citation.analysisId\n            };\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/citations\"), apiCitation);\n            // Convert response back to camelCase\n            return {\n                id: response.id || \"\",\n                text: response.text,\n                documentId: response.document_id,\n                highlightId: response.highlight_id,\n                page: response.page,\n                rects: response.rects,\n                messageId: response.message_id,\n                analysisId: response.analysis_id\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Upload a document with progress tracking\n   */ async uploadDocumentWithProgress (file, onProgress) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Use the progress-enabled upload method - using type assertion for schema compatibility\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.uploadWithProgress(\"/api/documents/upload\", formData, onProgress, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // Return placeholder document with the ID\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Uploads and verifies a document with progress tracking,\n   * ensuring it has valid financial data\n   */ async uploadAndVerifyDocumentWithProgress (file, onProgress) {\n        let autoVerify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        try {\n            // Create wrapper for progress that includes the stage\n            const uploadProgressWrapper = onProgress ? (progress)=>onProgress(progress * 0.4, \"Uploading file\") : undefined;\n            // Step 1: Upload the document (40% of total progress)\n            console.log(\"Uploading document...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(0, \"Starting upload\");\n            const initialDocument = await this.uploadDocumentWithProgress(file, uploadProgressWrapper);\n            // Step 2: Poll for document processing completion (40% of total progress)\n            console.log(\"Polling for document processing completion...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(40, \"Processing document\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Update progress during polling\n                if (onProgress) {\n                    const pollingProgress = 40 + Math.min(40, retries / maxRetries * 40);\n                    onProgress(pollingProgress, \"Processing document\");\n                }\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data (20% of total progress)\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(80, \"Verifying financial data\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Enhancing financial data\");\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Retrieving enhanced data\");\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            // Complete the process\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Document ready\");\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDMEM7QUFLWjtBQUU5QixzRUFBc0U7QUFDdEUsTUFBTUUsaUJBQWlCLENBQUNDO0lBQ3RCQyxRQUFRRCxLQUFLLENBQUMsY0FBY0E7SUFDNUIsSUFBSUEsTUFBTUUsUUFBUSxJQUFJRixNQUFNRSxRQUFRLENBQUNDLElBQUksSUFBSUgsTUFBTUUsUUFBUSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtRQUN2RSxNQUFNLElBQUlDLE1BQU1MLE1BQU1FLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNO0lBQzVDO0lBQ0EsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBMENPLE1BQU1DLGVBQWU7SUFDMUI7O0dBRUMsR0FDRCxNQUFNQyxnQkFBZUMsSUFBVTtRQUM3QixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxJQUFJQztZQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFIO1lBRXhCLHVEQUF1RDtZQUN2RCxNQUFNTCxPQUFPLE1BQU1OLG1EQUFVQSxDQUFDZSxZQUFZLENBQ3hDLHlCQUNBSCxVQUNBWCw2RUFBNEJBO1lBRzlCLGtGQUFrRjtZQUNsRixPQUFPO2dCQUNMZSxVQUFVO29CQUNSQyxJQUFJWCxLQUFLWSxXQUFXO29CQUNwQkMsVUFBVWIsS0FBS2EsUUFBUTtvQkFDdkJDLGlCQUFpQixJQUFJQyxPQUFPQyxXQUFXO29CQUN2Q0MsVUFBVVosS0FBS2EsSUFBSTtvQkFDbkJDLFVBQVVkLEtBQUtlLElBQUk7b0JBQ25CQyxRQUFRO2dCQUNWO2dCQUNBQyxhQUFhO2dCQUNiQyxxQkFBcUIsSUFBSVIsT0FBT0MsV0FBVztnQkFDM0NRLFNBQVMsRUFBRTtnQkFDWEMsZUFBZSxDQUFDO2dCQUNoQkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCM0IsS0FBSzRCLE1BQU07Z0JBQzdCQyxjQUFjN0IsS0FBSzRCLE1BQU0sS0FBSyxXQUFXNUIsS0FBSzhCLE9B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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cz9lZDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2Nlc3NlZERvY3VtZW50LCBEb2N1bWVudFVwbG9hZFJlc3BvbnNlLCBDaXRhdGlvbiB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgYXBpU2VydmljZSB9IGZyb20gJy4vYXBpU2VydmljZSc7XG5pbXBvcnQgeyBcbiAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSwgXG4gIFByb2Nlc3NlZERvY3VtZW50U2NoZW1hLFxuICBDaXRhdGlvblNjaGVtYVxufSBmcm9tICdAL3ZhbGlkYXRpb24vc2NoZW1hcyc7XG5cbi8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBBUEkgZXJyb3JzIC0ga2VlcGluZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvbnN0IGhhbmRsZUFwaUVycm9yID0gKGVycm9yOiBhbnkpOiBuZXZlciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5kYXRhICYmIGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgc2VydmVyJyk7XG59O1xuXG4vLyBEZWZpbmUgcmVzcG9uc2UgdHlwZXMgZm9yIGJldHRlciB0eXBlIHNhZmV0eVxuaW50ZXJmYWNlIERvY3VtZW50Q291bnRSZXNwb25zZSB7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBEb2N1bWVudFJlc3BvbnNlIGV4dGVuZHMgUHJvY2Vzc2VkRG9jdW1lbnQge1xuICAvLyBTdXBwb3J0IHNuYWtlX2Nhc2UgYmFja2VuZCBmb3JtYXRcbiAgcHJvY2Vzc2luZ19zdGF0dXM/OiBzdHJpbmc7XG4gIGNvbnRlbnRfdHlwZT86IHN0cmluZztcbiAgZXh0cmFjdGVkX2RhdGE/OiBhbnk7XG4gIGNvbmZpZGVuY2Vfc2NvcmU/OiBudW1iZXI7XG4gIGVycm9yX21lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBEb2N1bWVudFVybFJlc3BvbnNlIHtcbiAgdXJsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZSB7XG4gIGhhc0ZpbmFuY2lhbERhdGE6IGJvb2xlYW47XG4gIGRpYWdub3Npczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmluYW5jaWFsRGF0YVZlcmlmeVJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG4vLyBBUEkgY2l0YXRpb24gZm9ybWF0IChmb3IgcmVxdWVzdC9yZXNwb25zZSB0by9mcm9tIGJhY2tlbmQpXG5pbnRlcmZhY2UgQXBpQ2l0YXRpb24ge1xuICBpZD86IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICBkb2N1bWVudF9pZDogc3RyaW5nO1xuICBoaWdobGlnaHRfaWQ/OiBzdHJpbmc7XG4gIHBhZ2U6IG51bWJlcjtcbiAgcmVjdHM6IGFueVtdO1xuICBtZXNzYWdlX2lkPzogc3RyaW5nO1xuICBhbmFseXNpc19pZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGRvY3VtZW50c0FwaSA9IHtcbiAgLyoqXG4gICAqIFVwbG9hZHMgYSBkb2N1bWVudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBhc3luYyB1cGxvYWREb2N1bWVudChmaWxlOiBGaWxlKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFR5cGUgYXNzZXJ0aW9uIHRvIHJlc29sdmUgc2NoZW1hIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlTZXJ2aWNlLnBvc3RGb3JtRGF0YTxEb2N1bWVudFVwbG9hZFJlc3BvbnNlPihcbiAgICAgICAgJy9hcGkvZG9jdW1lbnRzL3VwbG9hZCcsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIGFzIGFueVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIGEgcGxhY2Vob2xkZXIgUHJvY2Vzc2VkRG9jdW1lbnQgdW50aWwgcmUtcHJvY2Vzc2luZyBpcyBjb21wbGV0ZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpZDogZGF0YS5kb2N1bWVudF9pZCxcbiAgICAgICAgICBmaWxlbmFtZTogZGF0YS5maWxlbmFtZSxcbiAgICAgICAgICB1cGxvYWRUaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgdXNlcklkOiAnY3VycmVudC11c2VyJywgLy8gV291bGQgY29tZSBmcm9tIGF1dGggaW4gYSByZWFsIGFwcFxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50VHlwZTogJ290aGVyJyxcbiAgICAgICAgZXh0cmFjdGlvblRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwZXJpb2RzOiBbXSxcbiAgICAgICAgZXh0cmFjdGVkRGF0YToge30sXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZTogMCxcbiAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIGVycm9yTWVzc2FnZTogZGF0YS5zdGF0dXMgPT09ICdmYWlsZWQnID8gZGF0YS5tZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZG9jdW1lbnRzXG4gICAqL1xuICBhc3luYyBsaXN0RG9jdW1lbnRzKHBhZ2U6IG51bWJlciA9IDEsIHBhZ2VTaXplOiBudW1iZXIgPSAxMCk6IFByb21pc2U8YW55W10+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGFwaVNlcnZpY2UuZ2V0KGAvYXBpL2RvY3VtZW50cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogR2V0cyBkb2N1bWVudCBjb3VudFxuICAgKi9cbiAgYXN5bmMgZ2V0RG9jdW1lbnRDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50Q291bnRSZXNwb25zZT4oJy9hcGkvZG9jdW1lbnRzL2NvdW50Jyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuY291bnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZG9jdW1lbnQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhXG4gICAqL1xuICBhc3luYyBjaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlTZXJ2aWNlLmdldDxGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2hlY2stZmluYW5jaWFsLWRhdGFgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBWZXJpZnkgYSBkb2N1bWVudCdzIGZpbmFuY2lhbCBkYXRhIGFuZCBvcHRpb25hbGx5IHRyaWdnZXIgcmUtZXh0cmFjdGlvblxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50SWQ6IHN0cmluZywgcmV0cnlFeHRyYWN0aW9uOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBkb2N1bWVudCBoYXMgZmluYW5jaWFsIGRhdGFcbiAgICAgIGNvbnN0IGNoZWNrUmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2hlY2stZmluYW5jaWFsLWRhdGFgKTtcbiAgICAgIFxuICAgICAgLy8gSWYgY2hlY2sgcGFzc2VzLCByZXR1cm4gc3VjY2Vzc1xuICAgICAgaWYgKGNoZWNrUmVzcG9uc2UuaGFzRmluYW5jaWFsRGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogY2hlY2tSZXNwb25zZS5kaWFnbm9zaXMgfHwgXCJEb2N1bWVudCBjb250ZW50IGF2YWlsYWJsZSBmb3IgYW5hbHlzaXNcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBjaGVjayBmYWlscyBhbmQgcmV0cnkgaXMgZW5hYmxlZCwgdHJ5IHZlcmlmaWNhdGlvbiBlbmRwb2ludCB3aGljaCB3aWxsIGFjY2VwdCBhbnkgY29udGVudFxuICAgICAgaWYgKHJldHJ5RXh0cmFjdGlvbikge1xuICAgICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UucG9zdDxGaW5hbmNpYWxEYXRhVmVyaWZ5UmVzcG9uc2U+KFxuICAgICAgICAgIGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L3ZlcmlmeS1maW5hbmNpYWwtZGF0YWAsXG4gICAgICAgICAgeyByZXRyeV9leHRyYWN0aW9uOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFdmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlscywgd2UnbGwgc3RpbGwgYWxsb3cgdXNpbmcgdGhlIGRvY3VtZW50XG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdXNlcnMgY2FuIHN0aWxsIHRyeSB0byB1c2UgZG9jdW1lbnRzIHRoYXQgbWlnaHQgbm90IGhhdmVcbiAgICAgIC8vIGlkZWFsIHN0cnVjdHVyZSBidXQgY291bGQgc3RpbGwgYmUgdXNlZnVsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLCAvLyBGb3JjZSBzdWNjZXNzIHRvIGFsbG93IGRvY3VtZW50IHVzZSByZWdhcmRsZXNzIG9mIGNvbnRlbnRcbiAgICAgICAgbWVzc2FnZTogXCJEb2N1bWVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzICh2ZXJpZmljYXRpb24gYnlwYXNzZWQpXCJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB2ZXJpZnlpbmcgZG9jdW1lbnQ6XCIsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHMsIHdlJ2xsIGFsbG93IGNvbnRpbnVpbmcgd2l0aCB0aGUgZG9jdW1lbnRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIC8vIEZvcmNlIHN1Y2Nlc3MgdG8gYWxsb3cgZG9jdW1lbnQgdXNlXG4gICAgICAgIG1lc3NhZ2U6IFwiRG9jdW1lbnQgYXZhaWxhYmxlIGZvciBhbmFseXNpcyAodmVyaWZpY2F0aW9uIGJ5cGFzc2VkKVwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWRzIGFuZCB2ZXJpZmllcyBhIGRvY3VtZW50LCBlbnN1cmluZyBpdCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFZlcmlmeURvY3VtZW50KFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIGF1dG9WZXJpZnk6IGJvb2xlYW4gPSB0cnVlXG4gICk6IFByb21pc2U8UHJvY2Vzc2VkRG9jdW1lbnQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBVcGxvYWQgdGhlIGRvY3VtZW50XG4gICAgICBjb25zb2xlLmxvZygnVXBsb2FkaW5nIGRvY3VtZW50Li4uJyk7XG4gICAgICBjb25zdCBpbml0aWFsRG9jdW1lbnQgPSBhd2FpdCB0aGlzLnVwbG9hZERvY3VtZW50KGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBTdGVwIDI6IFBvbGwgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvblxuICAgICAgY29uc29sZS5sb2coJ1BvbGxpbmcgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvbi4uLicpO1xuICAgICAgbGV0IGRvY3VtZW50ID0gaW5pdGlhbERvY3VtZW50O1xuICAgICAgbGV0IHJldHJpZXMgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDMwOyAvLyAzMCAqIDIgc2Vjb25kcyA9IDEgbWludXRlIG1heFxuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTsgLy8gV2FpdCAyIHNlY29uZHNcbiAgICAgICAgXG4gICAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCdzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBkb2N1bWVudCB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiByZXNwb25zZS5wcm9jZXNzaW5nU3RhdHVzIHx8IHJlc3BvbnNlLnByb2Nlc3Npbmdfc3RhdHVzIHx8IGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yTWVzc2FnZSB8fCByZXNwb25zZS5lcnJvcl9tZXNzYWdlIHx8IGRvY3VtZW50LmVycm9yTWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50IHN0YXR1cyBhZnRlciBhdHRlbXB0ICR7cmV0cmllcyArIDF9OiAke2RvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXN9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2RvY3VtZW50LmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvbGxpbmcgZG9jdW1lbnQgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cnlpbmcgZXZlbiBpZiBhbiBpbmRpdmlkdWFsIHBvbGwgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RlcCAzOiBJZiBhdXRvLXZlcmlmeSBpcyBlbmFibGVkLCBjaGVjayBhbmQgcG90ZW50aWFsbHkgZW5oYW5jZSBmaW5hbmNpYWwgZGF0YVxuICAgICAgaWYgKGF1dG9WZXJpZnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YS4uLicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFjaGVja1Jlc3VsdC5oYXNGaW5hbmNpYWxEYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgbmVlZHMgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGNoZWNrUmVzdWx0LmRpYWdub3Npcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGZpbmFuY2lhbCBkYXRhIGlzIG1pc3Npbmcgb3IgaW5zdWZmaWNpZW50LCB0cnkgdG8gdmVyaWZ5IGFuZCBlbmhhbmNlIGl0XG4gICAgICAgICAgICBjb25zdCB2ZXJpZnlSZXN1bHQgPSBhd2FpdCB0aGlzLnZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uIHJlc3VsdDonLCB2ZXJpZnlSZXN1bHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodmVyaWZ5UmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGRvY3VtZW50IHRvIGdldCB0aGUgZW5oYW5jZWQgZGF0YVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogR2V0IGEgc2VjdXJlIFVSTCB0byBhY2Nlc3MgdGhlIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudFVybChkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbnN0ZWFkIG9mIHVzaW5nIGEgc2FtcGxlIFBERiBVUkwgd2hpY2ggY2F1c2VzIENPUlMgaXNzdWVzLFxuICAgICAgLy8gZmV0Y2ggdGhlIGFjdHVhbCBkb2N1bWVudCBjb250ZW50IGFzIGJpbmFyeSBkYXRhIGFuZCBjcmVhdGUgYSBibG9iIFVSTFxuICAgICAgXG4gICAgICAvLyBGZXRjaCB0aGUgZG9jdW1lbnQgY29udGVudCBhcyBhIGJsb2JcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vZmlsZWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZW5kcG9pbnQgZXhpc3RzIGFuZCByZXR1cm5zIHByb3BlciBkYXRhXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIC8vIElmIHRoZSAvZmlsZSBlbmRwb2ludCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCB0cnkgYW4gYWx0ZXJuYXRpdmUgYXBwcm9hY2hcbiAgICAgICAgY29uc29sZS53YXJuKGBEb2N1bWVudCBmaWxlIGVuZHBvaW50IHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfSwgdHJ5aW5nIGFsdGVybmF0aXZlIGFwcHJvYWNoYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHRlcm5hdGl2ZSBhcHByb2FjaDogVXNlIHRoZSBiYWNrZW5kIEFQSSB0byBmZXRjaCB0aGUgZG9jdW1lbnQgZGlyZWN0bHlcbiAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBiYWNrZW5kIHNlcnZlcyB0aGUgZG9jdW1lbnQgY29udGVudCBhdCB0aGlzIGVuZHBvaW50XG4gICAgICAgIGNvbnN0IGRvY3VtZW50UmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldChgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfWAsIHVuZGVmaW5lZCwge1xuICAgICAgICAgIG1heEF0dGVtcHRzOiAxIC8vIE9ubHkgdHJ5IG9uY2UsIGRvbid0IHJldHJ5XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhlIGRvY3VtZW50IGhhcyByYXdfdGV4dCwgd2UgY2FuIGNyZWF0ZSBhIHNpbXBsZSBQREYgZnJvbSBpdFxuICAgICAgICBpZiAoZG9jdW1lbnRSZXNwb25zZS5yYXdfdGV4dCB8fCAoZG9jdW1lbnRSZXNwb25zZS5leHRyYWN0ZWREYXRhICYmIGRvY3VtZW50UmVzcG9uc2UuZXh0cmFjdGVkRGF0YS5yYXdfdGV4dCkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnRSZXNwb25zZS5yYXdfdGV4dCB8fCBkb2N1bWVudFJlc3BvbnNlLmV4dHJhY3RlZERhdGEucmF3X3RleHQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIFBERiBmcm9tIHRoZSB0ZXh0IHVzaW5nIGEgZGF0YSBVUkxcbiAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgdmVyeSBiYXNpYyBhcHByb2FjaCBmb3IgdGVzdGluZ1xuICAgICAgICAgIGNvbnN0IHBkZkJsb2IgPSBuZXcgQmxvYihbdGV4dF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSk7XG4gICAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocGRmQmxvYik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlLCB3ZSBjb3VsZG4ndCBmZXRjaCBhIHByb3BlciBkb2N1bWVudCAtIHNob3cgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcmV0cmlldmUgZG9jdW1lbnQgZmlsZS4gQmFja2VuZCByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBQREYgZGF0YSBhcyBhIGJsb2JcbiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIFVSTCBmb3IgdGhlIGJsb2JcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgZG9jdW1lbnQgVVJMOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGEgc2ltcGxlIHRleHQtYmFzZWQgUERGIGZvciBub3dcbiAgICAgIC8vIENyZWF0ZSBhIHNtYWxsIHBsYWNlaG9sZGVyIFBERiB3aXRoIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGBFcnJvciBsb2FkaW5nIGRvY3VtZW50OiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWA7XG4gICAgICBjb25zdCBwZGZCbG9iID0gbmV3IEJsb2IoW2Vycm9yVGV4dF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL3BkZicgfSk7XG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChwZGZCbG9iKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogR2V0IGFsbCBjaXRhdGlvbnMgZm9yIGEgZG9jdW1lbnRcbiAgICovXG4gIGFzeW5jIGdldERvY3VtZW50Q2l0YXRpb25zKGRvY3VtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8Q2l0YXRpb25bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PEFwaUNpdGF0aW9uW10+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L2NpdGF0aW9uc2ApO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIHJlc3BvbnNlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgZWFjaCBjaXRhdGlvblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UubWFwKGNpdGF0aW9uID0+ICh7XG4gICAgICAgICAgaWQ6IGNpdGF0aW9uLmlkIHx8ICcnLFxuICAgICAgICAgIHRleHQ6IGNpdGF0aW9uLnRleHQsXG4gICAgICAgICAgZG9jdW1lbnRJZDogY2l0YXRpb24uZG9jdW1lbnRfaWQsXG4gICAgICAgICAgaGlnaGxpZ2h0SWQ6IGNpdGF0aW9uLmhpZ2hsaWdodF9pZCxcbiAgICAgICAgICBwYWdlOiBjaXRhdGlvbi5wYWdlLFxuICAgICAgICAgIHJlY3RzOiBjaXRhdGlvbi5yZWN0cyxcbiAgICAgICAgICBtZXNzYWdlSWQ6IGNpdGF0aW9uLm1lc3NhZ2VfaWQsXG4gICAgICAgICAgYW5hbHlzaXNJZDogY2l0YXRpb24uYW5hbHlzaXNfaWRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gW107XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZG9jdW1lbnQgY2l0YXRpb25zOicsIGVycm9yKTtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNpdGF0aW9uIGluIGEgZG9jdW1lbnRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNpdGF0aW9uKGRvY3VtZW50SWQ6IHN0cmluZywgY2l0YXRpb246IE9taXQ8Q2l0YXRpb24sICdpZCc+KTogUHJvbWlzZTxDaXRhdGlvbj4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IHRvIHNuYWtlX2Nhc2UgZm9yIHRoZSBBUElcbiAgICAgIGNvbnN0IGFwaUNpdGF0aW9uOiBBcGlDaXRhdGlvbiA9IHtcbiAgICAgICAgdGV4dDogY2l0YXRpb24udGV4dCxcbiAgICAgICAgZG9jdW1lbnRfaWQ6IGRvY3VtZW50SWQsXG4gICAgICAgIGhpZ2hsaWdodF9pZDogY2l0YXRpb24uaGlnaGxpZ2h0SWQsXG4gICAgICAgIHBhZ2U6IGNpdGF0aW9uLnBhZ2UsXG4gICAgICAgIHJlY3RzOiBjaXRhdGlvbi5yZWN0cyxcbiAgICAgICAgbWVzc2FnZV9pZDogY2l0YXRpb24ubWVzc2FnZUlkLFxuICAgICAgICBhbmFseXNpc19pZDogY2l0YXRpb24uYW5hbHlzaXNJZFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLnBvc3Q8QXBpQ2l0YXRpb24+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L2NpdGF0aW9uc2AsIGFwaUNpdGF0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCByZXNwb25zZSBiYWNrIHRvIGNhbWVsQ2FzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmlkIHx8ICcnLFxuICAgICAgICB0ZXh0OiByZXNwb25zZS50ZXh0LFxuICAgICAgICBkb2N1bWVudElkOiByZXNwb25zZS5kb2N1bWVudF9pZCxcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IHJlc3BvbnNlLmhpZ2hsaWdodF9pZCxcbiAgICAgICAgcGFnZTogcmVzcG9uc2UucGFnZSxcbiAgICAgICAgcmVjdHM6IHJlc3BvbnNlLnJlY3RzLFxuICAgICAgICBtZXNzYWdlSWQ6IHJlc3BvbnNlLm1lc3NhZ2VfaWQsXG4gICAgICAgIGFuYWx5c2lzSWQ6IHJlc3BvbnNlLmFuYWx5c2lzX2lkXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFVwbG9hZCBhIGRvY3VtZW50IHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICovXG4gIGFzeW5jIHVwbG9hZERvY3VtZW50V2l0aFByb2dyZXNzKFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlcikgPT4gdm9pZFxuICApOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBwcm9ncmVzcy1lbmFibGVkIHVwbG9hZCBtZXRob2QgLSB1c2luZyB0eXBlIGFzc2VydGlvbiBmb3Igc2NoZW1hIGNvbXBhdGliaWxpdHlcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlTZXJ2aWNlLnVwbG9hZFdpdGhQcm9ncmVzczxEb2N1bWVudFVwbG9hZFJlc3BvbnNlPihcbiAgICAgICAgJy9hcGkvZG9jdW1lbnRzL3VwbG9hZCcsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBvblByb2dyZXNzLFxuICAgICAgICBEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIGFzIGFueVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIHBsYWNlaG9sZGVyIGRvY3VtZW50IHdpdGggdGhlIElEXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlkOiBkYXRhLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGZpbGVuYW1lOiBkYXRhLmZpbGVuYW1lLFxuICAgICAgICAgIHVwbG9hZFRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGZpbGVTaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICB1c2VySWQ6ICdjdXJyZW50LXVzZXInLFxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50VHlwZTogJ290aGVyJyxcbiAgICAgICAgZXh0cmFjdGlvblRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwZXJpb2RzOiBbXSxcbiAgICAgICAgZXh0cmFjdGVkRGF0YToge30sXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZTogMCxcbiAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIGVycm9yTWVzc2FnZTogZGF0YS5zdGF0dXMgPT09ICdmYWlsZWQnID8gZGF0YS5tZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWRzIGFuZCB2ZXJpZmllcyBhIGRvY3VtZW50IHdpdGggcHJvZ3Jlc3MgdHJhY2tpbmcsXG4gICAqIGVuc3VyaW5nIGl0IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YVxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnRXaXRoUHJvZ3Jlc3MoXG4gICAgZmlsZTogRmlsZSwgXG4gICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyLCBzdGFnZTogc3RyaW5nKSA9PiB2b2lkLFxuICAgIGF1dG9WZXJpZnk6IGJvb2xlYW4gPSB0cnVlXG4gICk6IFByb21pc2U8UHJvY2Vzc2VkRG9jdW1lbnQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIHdyYXBwZXIgZm9yIHByb2dyZXNzIHRoYXQgaW5jbHVkZXMgdGhlIHN0YWdlXG4gICAgICBjb25zdCB1cGxvYWRQcm9ncmVzc1dyYXBwZXIgPSBvblByb2dyZXNzIFxuICAgICAgICA/IChwcm9ncmVzczogbnVtYmVyKSA9PiBvblByb2dyZXNzKHByb2dyZXNzICogMC40LCAnVXBsb2FkaW5nIGZpbGUnKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIFxuICAgICAgLy8gU3RlcCAxOiBVcGxvYWQgdGhlIGRvY3VtZW50ICg0MCUgb2YgdG90YWwgcHJvZ3Jlc3MpXG4gICAgICBjb25zb2xlLmxvZygnVXBsb2FkaW5nIGRvY3VtZW50Li4uJyk7XG4gICAgICBvblByb2dyZXNzPy4oMCwgJ1N0YXJ0aW5nIHVwbG9hZCcpO1xuICAgICAgY29uc3QgaW5pdGlhbERvY3VtZW50ID0gYXdhaXQgdGhpcy51cGxvYWREb2N1bWVudFdpdGhQcm9ncmVzcyhmaWxlLCB1cGxvYWRQcm9ncmVzc1dyYXBwZXIpO1xuICAgICAgXG4gICAgICAvLyBTdGVwIDI6IFBvbGwgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvbiAoNDAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1BvbGxpbmcgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvbi4uLicpO1xuICAgICAgb25Qcm9ncmVzcz8uKDQwLCAnUHJvY2Vzc2luZyBkb2N1bWVudCcpO1xuICAgICAgXG4gICAgICBsZXQgZG9jdW1lbnQgPSBpbml0aWFsRG9jdW1lbnQ7XG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMzA7IC8vIDMwICogMiBzZWNvbmRzID0gMSBtaW51dGUgbWF4XG4gICAgICBcbiAgICAgIHdoaWxlIChyZXRyaWVzIDwgbWF4UmV0cmllcyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnZmFpbGVkJykge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpOyAvLyBXYWl0IDIgc2Vjb25kc1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGR1cmluZyBwb2xsaW5nXG4gICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgY29uc3QgcG9sbGluZ1Byb2dyZXNzID0gNDAgKyBNYXRoLm1pbig0MCwgKHJldHJpZXMgLyBtYXhSZXRyaWVzKSAqIDQwKTtcbiAgICAgICAgICBvblByb2dyZXNzKHBvbGxpbmdQcm9ncmVzcywgJ1Byb2Nlc3NpbmcgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGRvY3VtZW50J3MgY3VycmVudCBzdGF0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGRvY3VtZW50IHdpdGggdGhlIGxhdGVzdCBkYXRhXG4gICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IHJlc3BvbnNlLnByb2Nlc3NpbmdTdGF0dXMgfHwgcmVzcG9uc2UucHJvY2Vzc2luZ19zdGF0dXMgfHwgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSB8fCByZXNwb25zZS5jb250ZW50X3R5cGUgfHwgZG9jdW1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHJlc3BvbnNlLmNvbmZpZGVuY2VTY29yZSB8fCByZXNwb25zZS5jb25maWRlbmNlX3Njb3JlIHx8IGRvY3VtZW50LmNvbmZpZGVuY2VTY29yZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogcmVzcG9uc2UuZXJyb3JNZXNzYWdlIHx8IHJlc3BvbnNlLmVycm9yX21lc3NhZ2UgfHwgZG9jdW1lbnQuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRG9jdW1lbnQgc3RhdHVzIGFmdGVyIGF0dGVtcHQgJHtyZXRyaWVzICsgMX06ICR7ZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1c31gKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9jdW1lbnQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7ZG9jdW1lbnQuZXJyb3JNZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcG9sbGluZyBkb2N1bWVudCBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRyeWluZyBldmVuIGlmIGFuIGluZGl2aWR1YWwgcG9sbCBmYWlsc1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXRyaWVzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHByb2Nlc3NpbmcgdGltZWQgb3V0IG9yIGZhaWxlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGVwIDM6IElmIGF1dG8tdmVyaWZ5IGlzIGVuYWJsZWQsIGNoZWNrIGFuZCBwb3RlbnRpYWxseSBlbmhhbmNlIGZpbmFuY2lhbCBkYXRhICgyMCUgb2YgdG90YWwgcHJvZ3Jlc3MpXG4gICAgICBpZiAoYXV0b1ZlcmlmeSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGZpbmFuY2lhbCBkYXRhLi4uJyk7XG4gICAgICAgIG9uUHJvZ3Jlc3M/Lig4MCwgJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2hlY2tEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghY2hlY2tSZXN1bHQuaGFzRmluYW5jaWFsRGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IG5lZWRzIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBjaGVja1Jlc3VsdC5kaWFnbm9zaXMpO1xuICAgICAgICAgICAgb25Qcm9ncmVzcz8uKDg1LCAnRW5oYW5jaW5nIGZpbmFuY2lhbCBkYXRhJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGZpbmFuY2lhbCBkYXRhIGlzIG1pc3Npbmcgb3IgaW5zdWZmaWNpZW50LCB0cnkgdG8gdmVyaWZ5IGFuZCBlbmhhbmNlIGl0XG4gICAgICAgICAgICBjb25zdCB2ZXJpZnlSZXN1bHQgPSBhd2FpdCB0aGlzLnZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uIHJlc3VsdDonLCB2ZXJpZnlSZXN1bHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodmVyaWZ5UmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgb25Qcm9ncmVzcz8uKDkwLCAnUmV0cmlldmluZyBlbmhhbmNlZCBkYXRhJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZS1mZXRjaCB0aGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSBlbmhhbmNlZCBkYXRhXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkb2N1bWVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZERhdGE6IHJlc3BvbnNlLmV4dHJhY3RlZERhdGEgfHwgcmVzcG9uc2UuZXh0cmFjdGVkX2RhdGEgfHwgZG9jdW1lbnQuZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlsc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvbXBsZXRlIHRoZSBwcm9jZXNzXG4gICAgICBvblByb2dyZXNzPy4oMTAwLCAnRG9jdW1lbnQgcmVhZHknKTtcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxufTsiXSwibmFtZXMiOlsiYXBpU2VydmljZSIsIkRvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEiLCJoYW5kbGVBcGlFcnJvciIsImVycm9yIiwiY29uc29sZSIsInJlc3BvbnNlIiwiZGF0YSIsImRldGFpbCIsIkVycm9yIiwiZG9jdW1lbnRzQXBpIiwidXBsb2FkRG9jdW1lbnQiLCJmaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInBvc3RGb3JtRGF0YSIsIm1ldGFkYXRhIiwiaWQiLCJkb2N1bWVudF9pZCIsImZpbGVuYW1lIiwidXBsb2FkVGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZmlsZVNpemUiLCJzaXplIiwibWltZVR5cGUiLCJ0eXBlIiwidXNlcklkIiwiY29udGVudFR5cGUiLCJleHRyYWN0aW9uVGltZXN0YW1wIiwicGVyaW9kcyIsImV4dHJhY3RlZERhdGEiLCJjb25maWRlbmNlU2NvcmUiLCJwcm9jZXNzaW5nU3RhdHVzIiwic3RhdHVzIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsImxpc3REb2N1bWVudHMiLCJwYWdlIiwicGFnZVNpemUiLCJnZXQiLCJnZXREb2N1bWVudENvdW50IiwiY291bnQiLCJjaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YSIsImRvY3VtZW50SWQiLCJ2ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEiLCJyZXRyeUV4dHJhY3Rpb24iLCJjaGVja1Jlc3BvbnNlIiwiaGFzRmluYW5jaWFsRGF0YSIsInN1Y2Nlc3MiLCJkaWFnbm9zaXMiLCJ2ZXJpZnlSZXNwb25zZSIsInBvc3QiLCJyZXRyeV9leHRyYWN0aW9uIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnQiLCJhdXRvVmVyaWZ5IiwibG9nIiwiaW5pdGlhbERvY3VtZW50IiwiZG9jdW1lbnQiLCJyZXRyaWVzIiwibWF4UmV0cmllcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInByb2Nlc3Npbmdfc3RhdHVzIiwiY29udGVudF90eXBlIiwiZXh0cmFjdGVkX2RhdGEiLCJjb25maWRlbmNlX3Njb3JlIiwiZXJyb3JfbWVzc2FnZSIsImNoZWNrUmVzdWx0IiwidmVyaWZ5UmVzdWx0IiwiZ2V0RG9jdW1lbnRVcmwiLCJmZXRjaCIsIkFQSV9CQVNFX1VSTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsIndhcm4iLCJkb2N1bWVudFJlc3BvbnNlIiwibWF4QXR0ZW1wdHMiLCJyYXdfdGV4dCIsInRleHQiLCJwZGZCbG9iIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImJsb2IiLCJlcnJvclRleHQiLCJnZXREb2N1bWVudENpdGF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImNpdGF0aW9uIiwiaGlnaGxpZ2h0SWQiLCJoaWdobGlnaHRfaWQiLCJyZWN0cyIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJhbmFseXNpc0lkIiwiYW5hbHlzaXNfaWQiLCJjcmVhdGVDaXRhdGlvbiIsImFwaUNpdGF0aW9uIiwidXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwidXBsb2FkV2l0aFByb2dyZXNzIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJ1cGxvYWRQcm9ncmVzc1dyYXBwZXIiLCJwcm9ncmVzcyIsInBvbGxpbmdQcm9ncmVzcyIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/documents.ts\n"));

/***/ })

});