"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/page",{

/***/ "(app-pages-browser)/./src/lib/api/documents.ts":
/*!**********************************!*\
  !*** ./src/lib/api/documents.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   documentsApi: function() { return /* binding */ documentsApi; }\n/* harmony export */ });\n/* harmony import */ var _apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiService */ \"(app-pages-browser)/./src/lib/api/apiService.ts\");\n/* harmony import */ var _validation_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/validation/schemas */ \"(app-pages-browser)/./src/validation/schemas.ts\");\n\n\n// API base URL - would be configured based on environment\nconst API_BASE_URL = \"http://localhost:8000\" || 0;\n// Function to handle API errors - keeping for backwards compatibility\nconst handleApiError = (error)=>{\n    console.error(\"API Error:\", error);\n    if (error.response && error.response.data && error.response.data.detail) {\n        throw new Error(error.response.data.detail);\n    }\n    throw new Error(\"An error occurred while communicating with the server\");\n};\nconst documentsApi = {\n    /**\n   * Uploads a document to the server\n   */ async uploadDocument (file) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Type assertion to resolve schema compatibility issue\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.postFormData(\"/api/documents/upload\", formData, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // For now, return a placeholder ProcessedDocument until re-processing is complete\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Lists all documents\n   */ async listDocuments () {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents?page=\".concat(page, \"&page_size=\").concat(pageSize));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Gets document count\n   */ async getDocumentCount () {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/count\");\n            return response.count;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Checks if a document has valid financial data\n   */ async checkDocumentFinancialData (documentId) {\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Verify a document's financial data and optionally trigger re-extraction\n   */ async verifyDocumentFinancialData (documentId) {\n        let retryExtraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // First check if document has financial data\n            const checkResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n            // If check passes, return success\n            if (checkResponse.hasFinancialData) {\n                return {\n                    success: true,\n                    message: checkResponse.diagnosis || \"Document content available for analysis\"\n                };\n            }\n            // If check fails and retry is enabled, try verification endpoint which will accept any content\n            if (retryExtraction) {\n                const verifyResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/verify-financial-data\"), {\n                    retry_extraction: true\n                });\n                return verifyResponse;\n            }\n            // Even if verification fails, we'll still allow using the document\n            // This ensures users can still try to use documents that might not have\n            // ideal structure but could still be useful\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        } catch (error) {\n            console.error(\"Error verifying document:\", error);\n            // Even if verification fails, we'll allow continuing with the document\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        }\n    },\n    /**\n   * Uploads and verifies a document, ensuring it has valid financial data\n   */ async uploadAndVerifyDocument (file) {\n        let autoVerify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        try {\n            // Step 1: Upload the document\n            console.log(\"Uploading document...\");\n            const initialDocument = await this.uploadDocument(file);\n            // Step 2: Poll for document processing completion\n            console.log(\"Polling for document processing completion...\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get a secure URL to access the document\n   */ async getDocumentUrl (documentId) {\n        try {\n            // Instead of using a sample PDF URL which causes CORS issues,\n            // fetch the actual document content as binary data and create a blob URL\n            // Fetch the document content as a blob\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/documents/\").concat(documentId, \"/file\"), {\n                method: \"GET\",\n                headers: {\n                    \"Accept\": \"application/pdf\"\n                }\n            });\n            // Check if the endpoint exists and returns proper data\n            if (!response.ok) {\n                // If the /file endpoint doesn't exist, we'll try an alternative approach\n                console.warn(\"Document file endpoint returned \".concat(response.status, \", trying alternative approach\"));\n                // Alternative approach: Use the backend API to fetch the document directly\n                // This assumes the backend serves the document content at this endpoint\n                const documentResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId), undefined, {\n                    maxAttempts: 1 // Only try once, don't retry\n                });\n                // If the document has raw_text, we can create a simple PDF from it\n                if (documentResponse.raw_text || documentResponse.extractedData && documentResponse.extractedData.raw_text) {\n                    const text = documentResponse.raw_text || documentResponse.extractedData.raw_text;\n                    // Create a simple PDF from the text using a data URL\n                    // Note: This is a very basic approach for testing\n                    const pdfBlob = new Blob([\n                        text\n                    ], {\n                        type: \"application/pdf\"\n                    });\n                    return URL.createObjectURL(pdfBlob);\n                }\n                // If we get here, we couldn't fetch a proper document - show error\n                throw new Error(\"Could not retrieve document file. Backend returned \".concat(response.status));\n            }\n            // Get the PDF data as a blob\n            const blob = await response.blob();\n            // Create a URL for the blob\n            return URL.createObjectURL(blob);\n        } catch (error) {\n            console.error(\"Error creating document URL:\", error);\n            // Fallback to a simple text-based PDF for now\n            // Create a small placeholder PDF with an error message\n            const errorText = \"Error loading document: \".concat(error instanceof Error ? error.message : \"Unknown error\");\n            const pdfBlob = new Blob([\n                errorText\n            ], {\n                type: \"application/pdf\"\n            });\n            return URL.createObjectURL(pdfBlob);\n        }\n    },\n    /**\n   * Get all citations for a document\n   */ async getDocumentCitations (documentId) {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/citations\"));\n            // Ensure the response is an array\n            if (Array.isArray(response)) {\n                // Validate each citation\n                return response.map((citation)=>({\n                        id: citation.id || \"\",\n                        text: citation.text,\n                        documentId: citation.document_id,\n                        highlightId: citation.highlight_id,\n                        page: citation.page,\n                        rects: citation.rects,\n                        messageId: citation.message_id,\n                        analysisId: citation.analysis_id\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error getting document citations:\", error);\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Create a new citation in a document\n   */ async createCitation (documentId, citation) {\n        try {\n            // Convert to snake_case for the API\n            const apiCitation = {\n                text: citation.text,\n                document_id: documentId,\n                highlight_id: citation.highlightId,\n                page: citation.page,\n                rects: citation.rects,\n                message_id: citation.messageId,\n                analysis_id: citation.analysisId\n            };\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/citations\"), apiCitation);\n            // Convert response back to camelCase\n            return {\n                id: response.id || \"\",\n                text: response.text,\n                documentId: response.document_id,\n                highlightId: response.highlight_id,\n                page: response.page,\n                rects: response.rects,\n                messageId: response.message_id,\n                analysisId: response.analysis_id\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Upload a document with progress tracking\n   */ async uploadDocumentWithProgress (file, onProgress) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Use the progress-enabled upload method - using type assertion for schema compatibility\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.uploadWithProgress(\"/api/documents/upload\", formData, onProgress, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // Return placeholder document with the ID\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Uploads and verifies a document with progress tracking,\n   * ensuring it has valid financial data\n   */ async uploadAndVerifyDocumentWithProgress (file, onProgress) {\n        let autoVerify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        try {\n            // Create wrapper for progress that includes the stage\n            const uploadProgressWrapper = onProgress ? (progress)=>onProgress(progress * 0.4, \"Uploading file\") : undefined;\n            // Step 1: Upload the document (40% of total progress)\n            console.log(\"Uploading document...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(0, \"Starting upload\");\n            const initialDocument = await this.uploadDocumentWithProgress(file, uploadProgressWrapper);\n            // Step 2: Poll for document processing completion (40% of total progress)\n            console.log(\"Polling for document processing completion...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(40, \"Processing document\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Update progress during polling\n                if (onProgress) {\n                    const pollingProgress = 40 + Math.min(40, retries / maxRetries * 40);\n                    onProgress(pollingProgress, \"Processing document\");\n                }\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data (20% of total progress)\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(80, \"Verifying financial data\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Enhancing financial data\");\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Retrieving enhanced data\");\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            // Complete the process\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Document ready\");\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDMEM7QUFLWjtBQUU5QiwwREFBMEQ7QUFDMUQsTUFBTUUsZUFBZUMsdUJBQStCLElBQUk7QUFFeEQsc0VBQXNFO0FBQ3RFLE1BQU1HLGlCQUFpQixDQUFDQztJQUN0QkMsUUFBUUQsS0FBSyxDQUFDLGNBQWNBO0lBQzVCLElBQUlBLE1BQU1FLFFBQVEsSUFBSUYsTUFBTUUsUUFBUSxDQUFDQyxJQUFJLElBQUlILE1BQU1FLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7UUFDdkUsTUFBTSxJQUFJQyxNQUFNTCxNQUFNRSxRQUFRLENBQUNDLElBQUksQ0FBQ0MsTUFBTTtJQUM1QztJQUNBLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQTBDTyxNQUFNQyxlQUFlO0lBQzFCOztHQUVDLEdBQ0QsTUFBTUMsZ0JBQWVDLElBQVU7UUFDN0IsSUFBSTtZQUNGLE1BQU1DLFdBQVcsSUFBSUM7WUFDckJELFNBQVNFLE1BQU0sQ0FBQyxRQUFRSDtZQUV4Qix1REFBdUQ7WUFDdkQsTUFBTUwsT0FBTyxNQUFNVixtREFBVUEsQ0FBQ21CLFlBQVksQ0FDeEMseUJBQ0FILFVBQ0FmLDZFQUE0QkE7WUFHOUIsa0ZBQWtGO1lBQ2xGLE9BQU87Z0JBQ0xtQixVQUFVO29CQUNSQyxJQUFJWCxLQUFLWSxXQUFXO29CQUNwQkMsVUFBVWIsS0FBS2EsUUFBUTtvQkFDdkJDLGlCQUFpQixJQUFJQyxPQUFPQyxXQUFXO29CQUN2Q0MsVUFBVVosS0FBS2EsSUFBSTtvQkFDbkJDLFVBQVVkLEtBQUtlLElBQUk7b0JBQ25CQyxRQUFRO2dCQUNWO2dCQUNBQyxhQUFhO2dCQUNiQyxxQkFBcUIsSUFBSVIsT0FBT0MsV0FBVztnQkFDM0NRLFNBQVMsRUFBRTtnQkFDWEMsZUFBZSxDQUFDO2dCQUNoQkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCM0IsS0FBSzRCLE1BQU07Z0JB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T3hELE9BQU87WUFDZCxNQUFNRCxlQUFlQztRQUN2QjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS9kb2N1bWVudHMudHM/ZWQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9jZXNzZWREb2N1bWVudCwgRG9jdW1lbnRVcGxvYWRSZXNwb25zZSwgQ2l0YXRpb24gfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGFwaVNlcnZpY2UgfSBmcm9tICcuL2FwaVNlcnZpY2UnO1xuaW1wb3J0IHsgXG4gIERvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEsIFxuICBQcm9jZXNzZWREb2N1bWVudFNjaGVtYSxcbiAgQ2l0YXRpb25TY2hlbWFcbn0gZnJvbSAnQC92YWxpZGF0aW9uL3NjaGVtYXMnO1xuXG4vLyBBUEkgYmFzZSBVUkwgLSB3b3VsZCBiZSBjb25maWd1cmVkIGJhc2VkIG9uIGVudmlyb25tZW50XG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuXG4vLyBGdW5jdGlvbiB0byBoYW5kbGUgQVBJIGVycm9ycyAtIGtlZXBpbmcgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5jb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvcjogYW55KTogbmV2ZXIgPT4ge1xuICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgZXJyb3IucmVzcG9uc2UuZGF0YSAmJiBlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggdGhlIHNlcnZlcicpO1xufTtcblxuLy8gRGVmaW5lIHJlc3BvbnNlIHR5cGVzIGZvciBiZXR0ZXIgdHlwZSBzYWZldHlcbmludGVyZmFjZSBEb2N1bWVudENvdW50UmVzcG9uc2Uge1xuICBjb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRSZXNwb25zZSBleHRlbmRzIFByb2Nlc3NlZERvY3VtZW50IHtcbiAgLy8gU3VwcG9ydCBzbmFrZV9jYXNlIGJhY2tlbmQgZm9ybWF0XG4gIHByb2Nlc3Npbmdfc3RhdHVzPzogc3RyaW5nO1xuICBjb250ZW50X3R5cGU/OiBzdHJpbmc7XG4gIGV4dHJhY3RlZF9kYXRhPzogYW55O1xuICBjb25maWRlbmNlX3Njb3JlPzogbnVtYmVyO1xuICBlcnJvcl9tZXNzYWdlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRG9jdW1lbnRVcmxSZXNwb25zZSB7XG4gIHVybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2Uge1xuICBoYXNGaW5hbmNpYWxEYXRhOiBib29sZWFuO1xuICBkaWFnbm9zaXM6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuLy8gQVBJIGNpdGF0aW9uIGZvcm1hdCAoZm9yIHJlcXVlc3QvcmVzcG9uc2UgdG8vZnJvbSBiYWNrZW5kKVxuaW50ZXJmYWNlIEFwaUNpdGF0aW9uIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgZG9jdW1lbnRfaWQ6IHN0cmluZztcbiAgaGlnaGxpZ2h0X2lkPzogc3RyaW5nO1xuICBwYWdlOiBudW1iZXI7XG4gIHJlY3RzOiBhbnlbXTtcbiAgbWVzc2FnZV9pZD86IHN0cmluZztcbiAgYW5hbHlzaXNfaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBkb2N1bWVudHNBcGkgPSB7XG4gIC8qKlxuICAgKiBVcGxvYWRzIGEgZG9jdW1lbnQgdG8gdGhlIHNlcnZlclxuICAgKi9cbiAgYXN5bmMgdXBsb2FkRG9jdW1lbnQoZmlsZTogRmlsZSk6IFByb21pc2U8UHJvY2Vzc2VkRG9jdW1lbnQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBUeXBlIGFzc2VydGlvbiB0byByZXNvbHZlIHNjaGVtYSBjb21wYXRpYmlsaXR5IGlzc3VlXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpU2VydmljZS5wb3N0Rm9ybURhdGE8RG9jdW1lbnRVcGxvYWRSZXNwb25zZT4oXG4gICAgICAgICcvYXBpL2RvY3VtZW50cy91cGxvYWQnLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSBhcyBhbnlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIHJldHVybiBhIHBsYWNlaG9sZGVyIFByb2Nlc3NlZERvY3VtZW50IHVudGlsIHJlLXByb2Nlc3NpbmcgaXMgY29tcGxldGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaWQ6IGRhdGEuZG9jdW1lbnRfaWQsXG4gICAgICAgICAgZmlsZW5hbWU6IGRhdGEuZmlsZW5hbWUsXG4gICAgICAgICAgdXBsb2FkVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZmlsZVNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgIHVzZXJJZDogJ2N1cnJlbnQtdXNlcicsIC8vIFdvdWxkIGNvbWUgZnJvbSBhdXRoIGluIGEgcmVhbCBhcHBcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudFR5cGU6ICdvdGhlcicsXG4gICAgICAgIGV4dHJhY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGVyaW9kczogW10sXG4gICAgICAgIGV4dHJhY3RlZERhdGE6IHt9LFxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IDAsXG4gICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGRhdGEuc3RhdHVzID09PSAnZmFpbGVkJyA/IGRhdGEubWVzc2FnZSA6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogTGlzdHMgYWxsIGRvY3VtZW50c1xuICAgKi9cbiAgYXN5bmMgbGlzdERvY3VtZW50cyhwYWdlOiBudW1iZXIgPSAxLCBwYWdlU2l6ZTogbnVtYmVyID0gMTApOiBQcm9taXNlPGFueVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlTZXJ2aWNlLmdldChgL2FwaS9kb2N1bWVudHM/cGFnZT0ke3BhZ2V9JnBhZ2Vfc2l6ZT0ke3BhZ2VTaXplfWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldHMgZG9jdW1lbnQgY291bnRcbiAgICovXG4gIGFzeW5jIGdldERvY3VtZW50Q291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxEb2N1bWVudENvdW50UmVzcG9uc2U+KCcvYXBpL2RvY3VtZW50cy9jb3VudCcpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmNvdW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGRvY3VtZW50IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YVxuICAgKi9cbiAgYXN5bmMgY2hlY2tEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnRJZDogc3RyaW5nKTogUHJvbWlzZTxGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpU2VydmljZS5nZXQ8RmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L2NoZWNrLWZpbmFuY2lhbC1kYXRhYCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVmVyaWZ5IGEgZG9jdW1lbnQncyBmaW5hbmNpYWwgZGF0YSBhbmQgb3B0aW9uYWxseSB0cmlnZ2VyIHJlLWV4dHJhY3Rpb25cbiAgICovXG4gIGFzeW5jIHZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudElkOiBzdHJpbmcsIHJldHJ5RXh0cmFjdGlvbjogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxGaW5hbmNpYWxEYXRhVmVyaWZ5UmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgZG9jdW1lbnQgaGFzIGZpbmFuY2lhbCBkYXRhXG4gICAgICBjb25zdCBjaGVja1Jlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L2NoZWNrLWZpbmFuY2lhbC1kYXRhYCk7XG4gICAgICBcbiAgICAgIC8vIElmIGNoZWNrIHBhc3NlcywgcmV0dXJuIHN1Y2Nlc3NcbiAgICAgIGlmIChjaGVja1Jlc3BvbnNlLmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrUmVzcG9uc2UuZGlhZ25vc2lzIHx8IFwiRG9jdW1lbnQgY29udGVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzXCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgY2hlY2sgZmFpbHMgYW5kIHJldHJ5IGlzIGVuYWJsZWQsIHRyeSB2ZXJpZmljYXRpb24gZW5kcG9pbnQgd2hpY2ggd2lsbCBhY2NlcHQgYW55IGNvbnRlbnRcbiAgICAgIGlmIChyZXRyeUV4dHJhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgdmVyaWZ5UmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLnBvc3Q8RmluYW5jaWFsRGF0YVZlcmlmeVJlc3BvbnNlPihcbiAgICAgICAgICBgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS92ZXJpZnktZmluYW5jaWFsLWRhdGFgLFxuICAgICAgICAgIHsgcmV0cnlfZXh0cmFjdGlvbjogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB2ZXJpZnlSZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHMsIHdlJ2xsIHN0aWxsIGFsbG93IHVzaW5nIHRoZSBkb2N1bWVudFxuICAgICAgLy8gVGhpcyBlbnN1cmVzIHVzZXJzIGNhbiBzdGlsbCB0cnkgdG8gdXNlIGRvY3VtZW50cyB0aGF0IG1pZ2h0IG5vdCBoYXZlXG4gICAgICAvLyBpZGVhbCBzdHJ1Y3R1cmUgYnV0IGNvdWxkIHN0aWxsIGJlIHVzZWZ1bFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSwgLy8gRm9yY2Ugc3VjY2VzcyB0byBhbGxvdyBkb2N1bWVudCB1c2UgcmVnYXJkbGVzcyBvZiBjb250ZW50XG4gICAgICAgIG1lc3NhZ2U6IFwiRG9jdW1lbnQgYXZhaWxhYmxlIGZvciBhbmFseXNpcyAodmVyaWZpY2F0aW9uIGJ5cGFzc2VkKVwiXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdmVyaWZ5aW5nIGRvY3VtZW50OlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzLCB3ZSdsbCBhbGxvdyBjb250aW51aW5nIHdpdGggdGhlIGRvY3VtZW50XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLCAvLyBGb3JjZSBzdWNjZXNzIHRvIGFsbG93IGRvY3VtZW50IHVzZVxuICAgICAgICBtZXNzYWdlOiBcIkRvY3VtZW50IGF2YWlsYWJsZSBmb3IgYW5hbHlzaXMgKHZlcmlmaWNhdGlvbiBieXBhc3NlZClcIlxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVXBsb2FkcyBhbmQgdmVyaWZpZXMgYSBkb2N1bWVudCwgZW5zdXJpbmcgaXQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhXG4gICAqL1xuICBhc3luYyB1cGxvYWRBbmRWZXJpZnlEb2N1bWVudChcbiAgICBmaWxlOiBGaWxlLCBcbiAgICBhdXRvVmVyaWZ5OiBib29sZWFuID0gdHJ1ZVxuICApOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFN0ZXAgMTogVXBsb2FkIHRoZSBkb2N1bWVudFxuICAgICAgY29uc29sZS5sb2coJ1VwbG9hZGluZyBkb2N1bWVudC4uLicpO1xuICAgICAgY29uc3QgaW5pdGlhbERvY3VtZW50ID0gYXdhaXQgdGhpcy51cGxvYWREb2N1bWVudChmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gU3RlcCAyOiBQb2xsIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb25cbiAgICAgIGNvbnNvbGUubG9nKCdQb2xsaW5nIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24uLi4nKTtcbiAgICAgIGxldCBkb2N1bWVudCA9IGluaXRpYWxEb2N1bWVudDtcbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzMDsgLy8gMzAgKiAyIHNlY29uZHMgPSAxIG1pbnV0ZSBtYXhcbiAgICAgIFxuICAgICAgd2hpbGUgKHJldHJpZXMgPCBtYXhSZXRyaWVzICYmIGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdjb21wbGV0ZWQnICYmIGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7IC8vIFdhaXQgMiBzZWNvbmRzXG4gICAgICAgIFxuICAgICAgICAvLyBGZXRjaCB0aGUgZG9jdW1lbnQncyBjdXJyZW50IHN0YXRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxEb2N1bWVudFJlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudC5tZXRhZGF0YS5pZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgZG9jdW1lbnQgd2l0aCB0aGUgbGF0ZXN0IGRhdGFcbiAgICAgICAgICBkb2N1bWVudCA9IHtcbiAgICAgICAgICAgIC4uLmRvY3VtZW50LFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogcmVzcG9uc2UucHJvY2Vzc2luZ1N0YXR1cyB8fCByZXNwb25zZS5wcm9jZXNzaW5nX3N0YXR1cyB8fCBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgIGV4dHJhY3RlZERhdGE6IHJlc3BvbnNlLmV4dHJhY3RlZERhdGEgfHwgcmVzcG9uc2UuZXh0cmFjdGVkX2RhdGEgfHwgZG9jdW1lbnQuZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgICAgIHBlcmlvZHM6IHJlc3BvbnNlLnBlcmlvZHMgfHwgZG9jdW1lbnQucGVyaW9kcyxcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiByZXNwb25zZS5lcnJvck1lc3NhZ2UgfHwgcmVzcG9uc2UuZXJyb3JfbWVzc2FnZSB8fCBkb2N1bWVudC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBEb2N1bWVudCBzdGF0dXMgYWZ0ZXIgYXR0ZW1wdCAke3JldHJpZXMgKyAxfTogJHtkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb2N1bWVudCBwcm9jZXNzaW5nIGZhaWxlZDogJHtkb2N1bWVudC5lcnJvck1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwb2xsaW5nIGRvY3VtZW50IHN0YXR1czonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgdHJ5aW5nIGV2ZW4gaWYgYW4gaW5kaXZpZHVhbCBwb2xsIGZhaWxzXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgcHJvY2Vzc2luZyB0aW1lZCBvdXQgb3IgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMzogSWYgYXV0by12ZXJpZnkgaXMgZW5hYmxlZCwgY2hlY2sgYW5kIHBvdGVudGlhbGx5IGVuaGFuY2UgZmluYW5jaWFsIGRhdGFcbiAgICAgIGlmIChhdXRvVmVyaWZ5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgZmluYW5jaWFsIGRhdGEuLi4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IGF3YWl0IHRoaXMuY2hlY2tEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghY2hlY2tSZXN1bHQuaGFzRmluYW5jaWFsRGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IG5lZWRzIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBjaGVja1Jlc3VsdC5kaWFnbm9zaXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBmaW5hbmNpYWwgZGF0YSBpcyBtaXNzaW5nIG9yIGluc3VmZmljaWVudCwgdHJ5IHRvIHZlcmlmeSBhbmQgZW5oYW5jZSBpdFxuICAgICAgICAgICAgY29uc3QgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbiByZXN1bHQ6JywgdmVyaWZ5UmVzdWx0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlcmlmeVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlLWZldGNoIHRoZSBkb2N1bWVudCB0byBnZXQgdGhlIGVuaGFuY2VkIGRhdGFcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxEb2N1bWVudFJlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudC5tZXRhZGF0YS5pZH1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSB8fCByZXNwb25zZS5jb250ZW50X3R5cGUgfHwgZG9jdW1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgICAgIHBlcmlvZHM6IHJlc3BvbnNlLnBlcmlvZHMgfHwgZG9jdW1lbnQucGVyaW9kcyxcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHJlc3BvbnNlLmNvbmZpZGVuY2VTY29yZSB8fCByZXNwb25zZS5jb25maWRlbmNlX3Njb3JlIHx8IGRvY3VtZW50LmNvbmZpZGVuY2VTY29yZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldCBhIHNlY3VyZSBVUkwgdG8gYWNjZXNzIHRoZSBkb2N1bWVudFxuICAgKi9cbiAgYXN5bmMgZ2V0RG9jdW1lbnRVcmwoZG9jdW1lbnRJZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSW5zdGVhZCBvZiB1c2luZyBhIHNhbXBsZSBQREYgVVJMIHdoaWNoIGNhdXNlcyBDT1JTIGlzc3VlcyxcbiAgICAgIC8vIGZldGNoIHRoZSBhY3R1YWwgZG9jdW1lbnQgY29udGVudCBhcyBiaW5hcnkgZGF0YSBhbmQgY3JlYXRlIGEgYmxvYiBVUkxcbiAgICAgIFxuICAgICAgLy8gRmV0Y2ggdGhlIGRvY3VtZW50IGNvbnRlbnQgYXMgYSBibG9iXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L2ZpbGVgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL3BkZicsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVuZHBvaW50IGV4aXN0cyBhbmQgcmV0dXJucyBwcm9wZXIgZGF0YVxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAvLyBJZiB0aGUgL2ZpbGUgZW5kcG9pbnQgZG9lc24ndCBleGlzdCwgd2UnbGwgdHJ5IGFuIGFsdGVybmF0aXZlIGFwcHJvYWNoXG4gICAgICAgIGNvbnNvbGUud2FybihgRG9jdW1lbnQgZmlsZSBlbmRwb2ludCByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30sIHRyeWluZyBhbHRlcm5hdGl2ZSBhcHByb2FjaGApO1xuICAgICAgICBcbiAgICAgICAgLy8gQWx0ZXJuYXRpdmUgYXBwcm9hY2g6IFVzZSB0aGUgYmFja2VuZCBBUEkgdG8gZmV0Y2ggdGhlIGRvY3VtZW50IGRpcmVjdGx5XG4gICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgYmFja2VuZCBzZXJ2ZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQgYXQgdGhpcyBlbmRwb2ludFxuICAgICAgICBjb25zdCBkb2N1bWVudFJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQoYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH1gLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICBtYXhBdHRlbXB0czogMSAvLyBPbmx5IHRyeSBvbmNlLCBkb24ndCByZXRyeVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBoYXMgcmF3X3RleHQsIHdlIGNhbiBjcmVhdGUgYSBzaW1wbGUgUERGIGZyb20gaXRcbiAgICAgICAgaWYgKGRvY3VtZW50UmVzcG9uc2UucmF3X3RleHQgfHwgKGRvY3VtZW50UmVzcG9uc2UuZXh0cmFjdGVkRGF0YSAmJiBkb2N1bWVudFJlc3BvbnNlLmV4dHJhY3RlZERhdGEucmF3X3RleHQpKSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50UmVzcG9uc2UucmF3X3RleHQgfHwgZG9jdW1lbnRSZXNwb25zZS5leHRyYWN0ZWREYXRhLnJhd190ZXh0O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSBQREYgZnJvbSB0aGUgdGV4dCB1c2luZyBhIGRhdGEgVVJMXG4gICAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIHZlcnkgYmFzaWMgYXBwcm9hY2ggZm9yIHRlc3RpbmdcbiAgICAgICAgICBjb25zdCBwZGZCbG9iID0gbmV3IEJsb2IoW3RleHRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH0pO1xuICAgICAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHBkZkJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgY291bGRuJ3QgZmV0Y2ggYSBwcm9wZXIgZG9jdW1lbnQgLSBzaG93IGVycm9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJldHJpZXZlIGRvY3VtZW50IGZpbGUuIEJhY2tlbmQgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgUERGIGRhdGEgYXMgYSBibG9iXG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBVUkwgZm9yIHRoZSBibG9iXG4gICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGRvY3VtZW50IFVSTDpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBGYWxsYmFjayB0byBhIHNpbXBsZSB0ZXh0LWJhc2VkIFBERiBmb3Igbm93XG4gICAgICAvLyBDcmVhdGUgYSBzbWFsbCBwbGFjZWhvbGRlciBQREYgd2l0aCBhbiBlcnJvciBtZXNzYWdlXG4gICAgICBjb25zdCBlcnJvclRleHQgPSBgRXJyb3IgbG9hZGluZyBkb2N1bWVudDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gO1xuICAgICAgY29uc3QgcGRmQmxvYiA9IG5ldyBCbG9iKFtlcnJvclRleHRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9wZGYnIH0pO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocGRmQmxvYik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldCBhbGwgY2l0YXRpb25zIGZvciBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudENpdGF0aW9ucyhkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPENpdGF0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxBcGlDaXRhdGlvbltdPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSByZXNwb25zZSBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGVhY2ggY2l0YXRpb25cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChjaXRhdGlvbiA9PiAoe1xuICAgICAgICAgIGlkOiBjaXRhdGlvbi5pZCB8fCAnJyxcbiAgICAgICAgICB0ZXh0OiBjaXRhdGlvbi50ZXh0LFxuICAgICAgICAgIGRvY3VtZW50SWQ6IGNpdGF0aW9uLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGhpZ2hsaWdodElkOiBjaXRhdGlvbi5oaWdobGlnaHRfaWQsXG4gICAgICAgICAgcGFnZTogY2l0YXRpb24ucGFnZSxcbiAgICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgICAgbWVzc2FnZUlkOiBjaXRhdGlvbi5tZXNzYWdlX2lkLFxuICAgICAgICAgIGFuYWx5c2lzSWQ6IGNpdGF0aW9uLmFuYWx5c2lzX2lkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGRvY3VtZW50IGNpdGF0aW9uczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjaXRhdGlvbiBpbiBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBjcmVhdGVDaXRhdGlvbihkb2N1bWVudElkOiBzdHJpbmcsIGNpdGF0aW9uOiBPbWl0PENpdGF0aW9uLCAnaWQnPik6IFByb21pc2U8Q2l0YXRpb24+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCB0byBzbmFrZV9jYXNlIGZvciB0aGUgQVBJXG4gICAgICBjb25zdCBhcGlDaXRhdGlvbjogQXBpQ2l0YXRpb24gPSB7XG4gICAgICAgIHRleHQ6IGNpdGF0aW9uLnRleHQsXG4gICAgICAgIGRvY3VtZW50X2lkOiBkb2N1bWVudElkLFxuICAgICAgICBoaWdobGlnaHRfaWQ6IGNpdGF0aW9uLmhpZ2hsaWdodElkLFxuICAgICAgICBwYWdlOiBjaXRhdGlvbi5wYWdlLFxuICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgIG1lc3NhZ2VfaWQ6IGNpdGF0aW9uLm1lc3NhZ2VJZCxcbiAgICAgICAgYW5hbHlzaXNfaWQ6IGNpdGF0aW9uLmFuYWx5c2lzSWRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5wb3N0PEFwaUNpdGF0aW9uPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgLCBhcGlDaXRhdGlvbik7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgYmFjayB0byBjYW1lbENhc2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXNwb25zZS5pZCB8fCAnJyxcbiAgICAgICAgdGV4dDogcmVzcG9uc2UudGV4dCxcbiAgICAgICAgZG9jdW1lbnRJZDogcmVzcG9uc2UuZG9jdW1lbnRfaWQsXG4gICAgICAgIGhpZ2hsaWdodElkOiByZXNwb25zZS5oaWdobGlnaHRfaWQsXG4gICAgICAgIHBhZ2U6IHJlc3BvbnNlLnBhZ2UsXG4gICAgICAgIHJlY3RzOiByZXNwb25zZS5yZWN0cyxcbiAgICAgICAgbWVzc2FnZUlkOiByZXNwb25zZS5tZXNzYWdlX2lkLFxuICAgICAgICBhbmFseXNpc0lkOiByZXNwb25zZS5hbmFseXNpc19pZFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gICAqL1xuICBhc3luYyB1cGxvYWREb2N1bWVudFdpdGhQcm9ncmVzcyhcbiAgICBmaWxlOiBGaWxlLCBcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgcHJvZ3Jlc3MtZW5hYmxlZCB1cGxvYWQgbWV0aG9kIC0gdXNpbmcgdHlwZSBhc3NlcnRpb24gZm9yIHNjaGVtYSBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpU2VydmljZS51cGxvYWRXaXRoUHJvZ3Jlc3M8RG9jdW1lbnRVcGxvYWRSZXNwb25zZT4oXG4gICAgICAgICcvYXBpL2RvY3VtZW50cy91cGxvYWQnLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSBhcyBhbnlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBwbGFjZWhvbGRlciBkb2N1bWVudCB3aXRoIHRoZSBJRFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpZDogZGF0YS5kb2N1bWVudF9pZCxcbiAgICAgICAgICBmaWxlbmFtZTogZGF0YS5maWxlbmFtZSxcbiAgICAgICAgICB1cGxvYWRUaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgdXNlcklkOiAnY3VycmVudC11c2VyJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudFR5cGU6ICdvdGhlcicsXG4gICAgICAgIGV4dHJhY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGVyaW9kczogW10sXG4gICAgICAgIGV4dHJhY3RlZERhdGE6IHt9LFxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IDAsXG4gICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGRhdGEuc3RhdHVzID09PSAnZmFpbGVkJyA/IGRhdGEubWVzc2FnZSA6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVXBsb2FkcyBhbmQgdmVyaWZpZXMgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nLFxuICAgKiBlbnN1cmluZyBpdCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFZlcmlmeURvY3VtZW50V2l0aFByb2dyZXNzKFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlciwgc3RhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgICBhdXRvVmVyaWZ5OiBib29sZWFuID0gdHJ1ZVxuICApOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB3cmFwcGVyIGZvciBwcm9ncmVzcyB0aGF0IGluY2x1ZGVzIHRoZSBzdGFnZVxuICAgICAgY29uc3QgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyID0gb25Qcm9ncmVzcyBcbiAgICAgICAgPyAocHJvZ3Jlc3M6IG51bWJlcikgPT4gb25Qcm9ncmVzcyhwcm9ncmVzcyAqIDAuNCwgJ1VwbG9hZGluZyBmaWxlJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMTogVXBsb2FkIHRoZSBkb2N1bWVudCAoNDAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1VwbG9hZGluZyBkb2N1bWVudC4uLicpO1xuICAgICAgb25Qcm9ncmVzcz8uKDAsICdTdGFydGluZyB1cGxvYWQnKTtcbiAgICAgIGNvbnN0IGluaXRpYWxEb2N1bWVudCA9IGF3YWl0IHRoaXMudXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MoZmlsZSwgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyKTtcbiAgICAgIFxuICAgICAgLy8gU3RlcCAyOiBQb2xsIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24gKDQwJSBvZiB0b3RhbCBwcm9ncmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdQb2xsaW5nIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24uLi4nKTtcbiAgICAgIG9uUHJvZ3Jlc3M/Lig0MCwgJ1Byb2Nlc3NpbmcgZG9jdW1lbnQnKTtcbiAgICAgIFxuICAgICAgbGV0IGRvY3VtZW50ID0gaW5pdGlhbERvY3VtZW50O1xuICAgICAgbGV0IHJldHJpZXMgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDMwOyAvLyAzMCAqIDIgc2Vjb25kcyA9IDEgbWludXRlIG1heFxuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTsgLy8gV2FpdCAyIHNlY29uZHNcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBkdXJpbmcgcG9sbGluZ1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGNvbnN0IHBvbGxpbmdQcm9ncmVzcyA9IDQwICsgTWF0aC5taW4oNDAsIChyZXRyaWVzIC8gbWF4UmV0cmllcykgKiA0MCk7XG4gICAgICAgICAgb25Qcm9ncmVzcyhwb2xsaW5nUHJvZ3Jlc3MsICdQcm9jZXNzaW5nIGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCdzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBkb2N1bWVudCB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiByZXNwb25zZS5wcm9jZXNzaW5nU3RhdHVzIHx8IHJlc3BvbnNlLnByb2Nlc3Npbmdfc3RhdHVzIHx8IGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yTWVzc2FnZSB8fCByZXNwb25zZS5lcnJvcl9tZXNzYWdlIHx8IGRvY3VtZW50LmVycm9yTWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50IHN0YXR1cyBhZnRlciBhdHRlbXB0ICR7cmV0cmllcyArIDF9OiAke2RvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXN9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2RvY3VtZW50LmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvbGxpbmcgZG9jdW1lbnQgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cnlpbmcgZXZlbiBpZiBhbiBpbmRpdmlkdWFsIHBvbGwgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RlcCAzOiBJZiBhdXRvLXZlcmlmeSBpcyBlbmFibGVkLCBjaGVjayBhbmQgcG90ZW50aWFsbHkgZW5oYW5jZSBmaW5hbmNpYWwgZGF0YSAoMjAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgaWYgKGF1dG9WZXJpZnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YS4uLicpO1xuICAgICAgICBvblByb2dyZXNzPy4oODAsICdWZXJpZnlpbmcgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0Lmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBuZWVkcyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgY2hlY2tSZXN1bHQuZGlhZ25vc2lzKTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig4NSwgJ0VuaGFuY2luZyBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBmaW5hbmNpYWwgZGF0YSBpcyBtaXNzaW5nIG9yIGluc3VmZmljaWVudCwgdHJ5IHRvIHZlcmlmeSBhbmQgZW5oYW5jZSBpdFxuICAgICAgICAgICAgY29uc3QgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbiByZXN1bHQ6JywgdmVyaWZ5UmVzdWx0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlcmlmeVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig5MCwgJ1JldHJpZXZpbmcgZW5oYW5jZWQgZGF0YScpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGRvY3VtZW50IHRvIGdldCB0aGUgZW5oYW5jZWQgZGF0YVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb21wbGV0ZSB0aGUgcHJvY2Vzc1xuICAgICAgb25Qcm9ncmVzcz8uKDEwMCwgJ0RvY3VtZW50IHJlYWR5Jyk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbImFwaVNlcnZpY2UiLCJEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIiwiQVBJX0JBU0VfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJoYW5kbGVBcGlFcnJvciIsImVycm9yIiwiY29uc29sZSIsInJlc3BvbnNlIiwiZGF0YSIsImRldGFpbCIsIkVycm9yIiwiZG9jdW1lbnRzQXBpIiwidXBsb2FkRG9jdW1lbnQiLCJmaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInBvc3RGb3JtRGF0YSIsIm1ldGFkYXRhIiwiaWQiLCJkb2N1bWVudF9pZCIsImZpbGVuYW1lIiwidXBsb2FkVGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZmlsZVNpemUiLCJzaXplIiwibWltZVR5cGUiLCJ0eXBlIiwidXNlcklkIiwiY29udGVudFR5cGUiLCJleHRyYWN0aW9uVGltZXN0YW1wIiwicGVyaW9kcyIsImV4dHJhY3RlZERhdGEiLCJjb25maWRlbmNlU2NvcmUiLCJwcm9jZXNzaW5nU3RhdHVzIiwic3RhdHVzIiwiZXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsImxpc3REb2N1bWVudHMiLCJwYWdlIiwicGFnZVNpemUiLCJnZXQiLCJnZXREb2N1bWVudENvdW50IiwiY291bnQiLCJjaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YSIsImRvY3VtZW50SWQiLCJ2ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEiLCJyZXRyeUV4dHJhY3Rpb24iLCJjaGVja1Jlc3BvbnNlIiwiaGFzRmluYW5jaWFsRGF0YSIsInN1Y2Nlc3MiLCJkaWFnbm9zaXMiLCJ2ZXJpZnlSZXNwb25zZSIsInBvc3QiLCJyZXRyeV9leHRyYWN0aW9uIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnQiLCJhdXRvVmVyaWZ5IiwibG9nIiwiaW5pdGlhbERvY3VtZW50IiwiZG9jdW1lbnQiLCJyZXRyaWVzIiwibWF4UmV0cmllcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInByb2Nlc3Npbmdfc3RhdHVzIiwiY29udGVudF90eXBlIiwiZXh0cmFjdGVkX2RhdGEiLCJjb25maWRlbmNlX3Njb3JlIiwiZXJyb3JfbWVzc2FnZSIsImNoZWNrUmVzdWx0IiwidmVyaWZ5UmVzdWx0IiwiZ2V0RG9jdW1lbnRVcmwiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsIndhcm4iLCJkb2N1bWVudFJlc3BvbnNlIiwibWF4QXR0ZW1wdHMiLCJyYXdfdGV4dCIsInRleHQiLCJwZGZCbG9iIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImJsb2IiLCJlcnJvclRleHQiLCJnZXREb2N1bWVudENpdGF0aW9ucyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImNpdGF0aW9uIiwiaGlnaGxpZ2h0SWQiLCJoaWdobGlnaHRfaWQiLCJyZWN0cyIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJhbmFseXNpc0lkIiwiYW5hbHlzaXNfaWQiLCJjcmVhdGVDaXRhdGlvbiIsImFwaUNpdGF0aW9uIiwidXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwidXBsb2FkV2l0aFByb2dyZXNzIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJ1cGxvYWRQcm9ncmVzc1dyYXBwZXIiLCJwcm9ncmVzcyIsInBvbGxpbmdQcm9ncmVzcyIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/documents.ts\n"));

/***/ })

});