"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/page",{

/***/ "(app-pages-browser)/./src/lib/api/documents.ts":
/*!**********************************!*\
  !*** ./src/lib/api/documents.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   documentsApi: function() { return /* binding */ documentsApi; }\n/* harmony export */ });\n/* harmony import */ var _apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiService */ \"(app-pages-browser)/./src/lib/api/apiService.ts\");\n/* harmony import */ var _validation_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/validation/schemas */ \"(app-pages-browser)/./src/validation/schemas.ts\");\n\n\n// Function to handle API errors - keeping for backwards compatibility\nconst handleApiError = (error)=>{\n    console.error(\"API Error:\", error);\n    if (error.response && error.response.data && error.response.data.detail) {\n        throw new Error(error.response.data.detail);\n    }\n    throw new Error(\"An error occurred while communicating with the server\");\n};\nconst documentsApi = {\n    /**\n   * Uploads a document to the server\n   */ async uploadDocument (file) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Type assertion to resolve schema compatibility issue\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.postFormData(\"/api/documents/upload\", formData, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // For now, return a placeholder ProcessedDocument until re-processing is complete\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Lists all documents\n   */ async listDocuments () {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents?page=\".concat(page, \"&page_size=\").concat(pageSize));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Gets document count\n   */ async getDocumentCount () {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/count\");\n            return response.count;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Checks if a document has valid financial data\n   */ async checkDocumentFinancialData (documentId) {\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Verify a document's financial data and optionally trigger re-extraction\n   */ async verifyDocumentFinancialData (documentId) {\n        let retryExtraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // First check if document has financial data\n            const checkResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n            // If check passes, return success\n            if (checkResponse.hasFinancialData) {\n                return {\n                    success: true,\n                    message: checkResponse.diagnosis || \"Document content available for analysis\"\n                };\n            }\n            // If check fails and retry is enabled, try verification endpoint which will accept any content\n            if (retryExtraction) {\n                const verifyResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/verify-financial-data\"), {\n                    retry_extraction: true\n                });\n                return verifyResponse;\n            }\n            // Even if verification fails, we'll still allow using the document\n            // This ensures users can still try to use documents that might not have\n            // ideal structure but could still be useful\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        } catch (error) {\n            console.error(\"Error verifying document:\", error);\n            // Even if verification fails, we'll allow continuing with the document\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        }\n    },\n    /**\n   * Uploads and verifies a document, ensuring it has valid financial data\n   */ async uploadAndVerifyDocument (file) {\n        let autoVerify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        try {\n            // Step 1: Upload the document\n            console.log(\"Uploading document...\");\n            const initialDocument = await this.uploadDocument(file);\n            // Step 2: Poll for document processing completion\n            console.log(\"Polling for document processing completion...\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get a secure URL to access the document\n   */ async getDocumentUrl (documentId) {\n        try {\n            // Instead of making an API request, construct the URL directly\n            // This assumes the backend serves document content at this endpoint\n            return \"http://localhost:8000/api/documents/\".concat(documentId, \"/content\");\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get all citations for a document\n   */ async getDocumentCitations (documentId) {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/citations\"));\n            // Ensure the response is an array\n            if (Array.isArray(response)) {\n                // Validate each citation\n                return response.map((citation)=>({\n                        id: citation.id || \"\",\n                        text: citation.text,\n                        documentId: citation.document_id,\n                        highlightId: citation.highlight_id,\n                        page: citation.page,\n                        rects: citation.rects,\n                        messageId: citation.message_id,\n                        analysisId: citation.analysis_id\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error getting document citations:\", error);\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Create a new citation in a document\n   */ async createCitation (documentId, citation) {\n        try {\n            // Convert to snake_case for the API\n            const apiCitation = {\n                text: citation.text,\n                document_id: documentId,\n                highlight_id: citation.highlightId,\n                page: citation.page,\n                rects: citation.rects,\n                message_id: citation.messageId,\n                analysis_id: citation.analysisId\n            };\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/citations\"), apiCitation);\n            // Convert response back to camelCase\n            return {\n                id: response.id || \"\",\n                text: response.text,\n                documentId: response.document_id,\n                highlightId: response.highlight_id,\n                page: response.page,\n                rects: response.rects,\n                messageId: response.message_id,\n                analysisId: response.analysis_id\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Upload a document with progress tracking\n   */ async uploadDocumentWithProgress (file, onProgress) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Use the progress-enabled upload method - using type assertion for schema compatibility\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.uploadWithProgress(\"/api/documents/upload\", formData, onProgress, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // Return placeholder document with the ID\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Uploads and verifies a document with progress tracking,\n   * ensuring it has valid financial data\n   */ async uploadAndVerifyDocumentWithProgress (file, onProgress) {\n        let autoVerify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        try {\n            // Create wrapper for progress that includes the stage\n            const uploadProgressWrapper = onProgress ? (progress)=>onProgress(progress * 0.4, \"Uploading file\") : undefined;\n            // Step 1: Upload the document (40% of total progress)\n            console.log(\"Uploading document...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(0, \"Starting upload\");\n            const initialDocument = await this.uploadDocumentWithProgress(file, uploadProgressWrapper);\n            // Step 2: Poll for document processing completion (40% of total progress)\n            console.log(\"Polling for document processing completion...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(40, \"Processing document\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Update progress during polling\n                if (onProgress) {\n                    const pollingProgress = 40 + Math.min(40, retries / maxRetries * 40);\n                    onProgress(pollingProgress, \"Processing document\");\n                }\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data (20% of total progress)\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(80, \"Verifying financial data\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Enhancing financial data\");\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Retrieving enhanced data\");\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            // Complete the process\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Document ready\");\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDMEM7QUFLWjtBQUU5QixzRUFBc0U7QUFDdEUsTUFBTUUsaUJBQWlCLENBQUNDO0lBQ3RCQyxRQUFRRCxLQUFLLENBQUMsY0FBY0E7SUFDNUIsSUFBSUEsTUFBTUUsUUFBUSxJQUFJRixNQUFNRSxRQUFRLENBQUNDLElBQUksSUFBSUgsTUFBTUUsUUFBUSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtRQUN2RSxNQUFNLElBQUlDLE1BQU1MLE1BQU1FLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNO0lBQzVDO0lBQ0EsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBMENPLE1BQU1DLGVBQWU7SUFDMUI7O0dBRUMsR0FDRCxNQUFNQyxnQkFBZUMsSUFBVTtRQUM3QixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxJQUFJQztZQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFIO1lBRXhCLHVEQUF1RDtZQUN2RCxNQUFNTCxPQUFPLE1BQU1OLG1EQUFVQSxDQUFDZSxZQUFZLENBQ3hDLHlCQUNBSCxVQUNBWCw2RUFBNEJBO1lBRzlCLGtGQUFrRjtZQUNsRixPQUFPO2dCQUNMZSxVQUFVO29CQUNSQyxJQUFJWCxLQUFLWSxXQUFXO29CQUNwQkMsVUFBVWIsS0FBS2EsUUFBUTtvQkFDdkJDLGlCQUFpQixJQUFJQyxPQUFPQyxXQUFXO29CQUN2Q0MsVUFBVVosS0FBS2EsSUFBSTtvQkFDbkJDLFVBQVVkLEtBQUtlLElBQUk7b0JBQ25CQyxRQUFRO2dCQUNWO2dCQUNBQyxhQUFhO2dCQUNiQyxxQkFBcUIsSUFBSVIsT0FBT0MsV0FBVztnQkFDM0NRLFNBQVMsRUFBRTtnQkFDWEMsZUFBZSxDQUFDO2dCQUNoQkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCM0IsS0FBSzRCLE1BQU07Z0JBQzdCQyxjQUFjN0IsS0FBSzRCLE1BQU0sS0FBSyxXQUFXNUIsS0FBSzhCLE9B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ZUFBZSxNQUFNLElBQUksQ0FBQ3pCLDJCQUEyQixDQUFDYSxTQUFTM0MsUUFBUSxDQUFDQyxFQUFFLEVBQUU7d0JBQ2xGYixRQUFRcUQsR0FBRyxDQUFDLHVDQUF1Q2M7d0JBRW5ELElBQUlBLGFBQWFyQixPQUFPLEVBQUU7NEJBQ3hCdUMsdUJBQUFBLGlDQUFBQSxXQUFhLElBQUk7NEJBRWpCLGlEQUFpRDs0QkFDakQsTUFBTXBGLFdBQVcsTUFBTUwsbURBQVVBLENBQUN5QyxHQUFHLENBQW1CLGtCQUF1QyxPQUFyQmtCLFNBQVMzQyxRQUFRLENBQUNDLEVBQUU7NEJBRTlGMEMsV0FBVztnQ0FDVCxHQUFHQSxRQUFRO2dDQUNYL0IsYUFBYXZCLFNBQVN1QixXQUFXLElBQUl2QixTQUFTNkQsWUFBWSxJQUFJUCxTQUFTL0IsV0FBVztnQ0FDbEZHLGVBQWUxQixTQUFTMEIsYUFBYSxJQUFJMUIsU0FBUzhELGNBQWMsSUFBSVIsU0FBUzVCLGFBQWE7Z0NBQzFGRCxTQUFTekIsU0FBU3lCLE9BQU8sSUFBSTZCLFNBQVM3QixPQUFPO2dDQUM3Q0UsaUJBQWlCM0IsU0FBUzJCLGVBQWUsSUFBSTNCLFNBQVMrRCxnQkFBZ0IsSUFBSVQsU0FBUzNCLGVBQWU7NEJBQ3BHO3dCQUNGO29CQUNGLE9BQU87d0JBQ0w1QixRQUFRcUQsR0FBRyxDQUFDO29CQUNkO2dCQUNGLEVBQUUsT0FBT3RELE9BQU87b0JBQ2RDLFFBQVFELEtBQUssQ0FBQyw2Q0FBNkNBO2dCQUMzRCxzQ0FBc0M7Z0JBQ3hDO1lBQ0Y7WUFFQSx1QkFBdUI7WUFDdkJzRix1QkFBQUEsaUNBQUFBLFdBQWEsS0FBSztZQUNsQixPQUFPOUI7UUFDVCxFQUFFLE9BQU94RCxPQUFPO1lBQ2QsTUFBTUQsZUFBZUM7UUFDdkI7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkvZG9jdW1lbnRzLnRzP2VkMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvY2Vzc2VkRG9jdW1lbnQsIERvY3VtZW50VXBsb2FkUmVzcG9uc2UsIENpdGF0aW9uIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBhcGlTZXJ2aWNlIH0gZnJvbSAnLi9hcGlTZXJ2aWNlJztcbmltcG9ydCB7IFxuICBEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hLCBcbiAgUHJvY2Vzc2VkRG9jdW1lbnRTY2hlbWEsXG4gIENpdGF0aW9uU2NoZW1hXG59IGZyb20gJ0AvdmFsaWRhdGlvbi9zY2hlbWFzJztcblxuLy8gRnVuY3Rpb24gdG8gaGFuZGxlIEFQSSBlcnJvcnMgLSBrZWVwaW5nIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuY29uc3QgaGFuZGxlQXBpRXJyb3IgPSAoZXJyb3I6IGFueSk6IG5ldmVyID0+IHtcbiAgY29uc29sZS5lcnJvcignQVBJIEVycm9yOicsIGVycm9yKTtcbiAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLmRhdGEgJiYgZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBzZXJ2ZXInKTtcbn07XG5cbi8vIERlZmluZSByZXNwb25zZSB0eXBlcyBmb3IgYmV0dGVyIHR5cGUgc2FmZXR5XG5pbnRlcmZhY2UgRG9jdW1lbnRDb3VudFJlc3BvbnNlIHtcbiAgY291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIERvY3VtZW50UmVzcG9uc2UgZXh0ZW5kcyBQcm9jZXNzZWREb2N1bWVudCB7XG4gIC8vIFN1cHBvcnQgc25ha2VfY2FzZSBiYWNrZW5kIGZvcm1hdFxuICBwcm9jZXNzaW5nX3N0YXR1cz86IHN0cmluZztcbiAgY29udGVudF90eXBlPzogc3RyaW5nO1xuICBleHRyYWN0ZWRfZGF0YT86IGFueTtcbiAgY29uZmlkZW5jZV9zY29yZT86IG51bWJlcjtcbiAgZXJyb3JfbWVzc2FnZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIERvY3VtZW50VXJsUmVzcG9uc2Uge1xuICB1cmw6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlIHtcbiAgaGFzRmluYW5jaWFsRGF0YTogYm9vbGVhbjtcbiAgZGlhZ25vc2lzOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGaW5hbmNpYWxEYXRhVmVyaWZ5UmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbi8vIEFQSSBjaXRhdGlvbiBmb3JtYXQgKGZvciByZXF1ZXN0L3Jlc3BvbnNlIHRvL2Zyb20gYmFja2VuZClcbmludGVyZmFjZSBBcGlDaXRhdGlvbiB7XG4gIGlkPzogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIGRvY3VtZW50X2lkOiBzdHJpbmc7XG4gIGhpZ2hsaWdodF9pZD86IHN0cmluZztcbiAgcGFnZTogbnVtYmVyO1xuICByZWN0czogYW55W107XG4gIG1lc3NhZ2VfaWQ/OiBzdHJpbmc7XG4gIGFuYWx5c2lzX2lkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgZG9jdW1lbnRzQXBpID0ge1xuICAvKipcbiAgICogVXBsb2FkcyBhIGRvY3VtZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIHVwbG9hZERvY3VtZW50KGZpbGU6IEZpbGUpOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gVHlwZSBhc3NlcnRpb24gdG8gcmVzb2x2ZSBzY2hlbWEgY29tcGF0aWJpbGl0eSBpc3N1ZVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFwaVNlcnZpY2UucG9zdEZvcm1EYXRhPERvY3VtZW50VXBsb2FkUmVzcG9uc2U+KFxuICAgICAgICAnL2FwaS9kb2N1bWVudHMvdXBsb2FkJyxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIERvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEgYXMgYW55XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBGb3Igbm93LCByZXR1cm4gYSBwbGFjZWhvbGRlciBQcm9jZXNzZWREb2N1bWVudCB1bnRpbCByZS1wcm9jZXNzaW5nIGlzIGNvbXBsZXRlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGlkOiBkYXRhLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGZpbGVuYW1lOiBkYXRhLmZpbGVuYW1lLFxuICAgICAgICAgIHVwbG9hZFRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGZpbGVTaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICB1c2VySWQ6ICdjdXJyZW50LXVzZXInLCAvLyBXb3VsZCBjb21lIGZyb20gYXV0aCBpbiBhIHJlYWwgYXBwXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnb3RoZXInLFxuICAgICAgICBleHRyYWN0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHBlcmlvZHM6IFtdLFxuICAgICAgICBleHRyYWN0ZWREYXRhOiB7fSxcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiAwLFxuICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBkYXRhLnN0YXR1cyA9PT0gJ2ZhaWxlZCcgPyBkYXRhLm1lc3NhZ2UgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIExpc3RzIGFsbCBkb2N1bWVudHNcbiAgICovXG4gIGFzeW5jIGxpc3REb2N1bWVudHMocGFnZTogbnVtYmVyID0gMSwgcGFnZVNpemU6IG51bWJlciA9IDEwKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpU2VydmljZS5nZXQoYC9hcGkvZG9jdW1lbnRzP3BhZ2U9JHtwYWdlfSZwYWdlX3NpemU9JHtwYWdlU2l6ZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZXRzIGRvY3VtZW50IGNvdW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudENvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRDb3VudFJlc3BvbnNlPignL2FwaS9kb2N1bWVudHMvY291bnQnKTtcbiAgICAgIHJldHVybiByZXNwb25zZS5jb3VudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBkb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIGNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8RmluYW5jaWFsRGF0YUNoZWNrUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGFwaVNlcnZpY2UuZ2V0PEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaGVjay1maW5hbmNpYWwtZGF0YWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFZlcmlmeSBhIGRvY3VtZW50J3MgZmluYW5jaWFsIGRhdGEgYW5kIG9wdGlvbmFsbHkgdHJpZ2dlciByZS1leHRyYWN0aW9uXG4gICAqL1xuICBhc3luYyB2ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnRJZDogc3RyaW5nLCByZXRyeUV4dHJhY3Rpb246IGJvb2xlYW4gPSBmYWxzZSk6IFByb21pc2U8RmluYW5jaWFsRGF0YVZlcmlmeVJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRvY3VtZW50IGhhcyBmaW5hbmNpYWwgZGF0YVxuICAgICAgY29uc3QgY2hlY2tSZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaGVjay1maW5hbmNpYWwtZGF0YWApO1xuICAgICAgXG4gICAgICAvLyBJZiBjaGVjayBwYXNzZXMsIHJldHVybiBzdWNjZXNzXG4gICAgICBpZiAoY2hlY2tSZXNwb25zZS5oYXNGaW5hbmNpYWxEYXRhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVja1Jlc3BvbnNlLmRpYWdub3NpcyB8fCBcIkRvY3VtZW50IGNvbnRlbnQgYXZhaWxhYmxlIGZvciBhbmFseXNpc1wiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIGNoZWNrIGZhaWxzIGFuZCByZXRyeSBpcyBlbmFibGVkLCB0cnkgdmVyaWZpY2F0aW9uIGVuZHBvaW50IHdoaWNoIHdpbGwgYWNjZXB0IGFueSBjb250ZW50XG4gICAgICBpZiAocmV0cnlFeHRyYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmeVJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5wb3N0PEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZT4oXG4gICAgICAgICAgYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vdmVyaWZ5LWZpbmFuY2lhbC1kYXRhYCxcbiAgICAgICAgICB7IHJldHJ5X2V4dHJhY3Rpb246IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdmVyaWZ5UmVzcG9uc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzLCB3ZSdsbCBzdGlsbCBhbGxvdyB1c2luZyB0aGUgZG9jdW1lbnRcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB1c2VycyBjYW4gc3RpbGwgdHJ5IHRvIHVzZSBkb2N1bWVudHMgdGhhdCBtaWdodCBub3QgaGF2ZVxuICAgICAgLy8gaWRlYWwgc3RydWN0dXJlIGJ1dCBjb3VsZCBzdGlsbCBiZSB1c2VmdWxcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIC8vIEZvcmNlIHN1Y2Nlc3MgdG8gYWxsb3cgZG9jdW1lbnQgdXNlIHJlZ2FyZGxlc3Mgb2YgY29udGVudFxuICAgICAgICBtZXNzYWdlOiBcIkRvY3VtZW50IGF2YWlsYWJsZSBmb3IgYW5hbHlzaXMgKHZlcmlmaWNhdGlvbiBieXBhc3NlZClcIlxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHZlcmlmeWluZyBkb2N1bWVudDpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBFdmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlscywgd2UnbGwgYWxsb3cgY29udGludWluZyB3aXRoIHRoZSBkb2N1bWVudFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSwgLy8gRm9yY2Ugc3VjY2VzcyB0byBhbGxvdyBkb2N1bWVudCB1c2VcbiAgICAgICAgbWVzc2FnZTogXCJEb2N1bWVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzICh2ZXJpZmljYXRpb24gYnlwYXNzZWQpXCJcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFVwbG9hZHMgYW5kIHZlcmlmaWVzIGEgZG9jdW1lbnQsIGVuc3VyaW5nIGl0IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YVxuICAgKi9cbiAgYXN5bmMgdXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnQoXG4gICAgZmlsZTogRmlsZSwgXG4gICAgYXV0b1ZlcmlmeTogYm9vbGVhbiA9IHRydWVcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTdGVwIDE6IFVwbG9hZCB0aGUgZG9jdW1lbnRcbiAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRpbmcgZG9jdW1lbnQuLi4nKTtcbiAgICAgIGNvbnN0IGluaXRpYWxEb2N1bWVudCA9IGF3YWl0IHRoaXMudXBsb2FkRG9jdW1lbnQoZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMjogUG9sbCBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uXG4gICAgICBjb25zb2xlLmxvZygnUG9sbGluZyBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uLi4uJyk7XG4gICAgICBsZXQgZG9jdW1lbnQgPSBpbml0aWFsRG9jdW1lbnQ7XG4gICAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMzA7IC8vIDMwICogMiBzZWNvbmRzID0gMSBtaW51dGUgbWF4XG4gICAgICBcbiAgICAgIHdoaWxlIChyZXRyaWVzIDwgbWF4UmV0cmllcyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJyAmJiBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnZmFpbGVkJykge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpOyAvLyBXYWl0IDIgc2Vjb25kc1xuICAgICAgICBcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGRvY3VtZW50J3MgY3VycmVudCBzdGF0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGRvY3VtZW50IHdpdGggdGhlIGxhdGVzdCBkYXRhXG4gICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IHJlc3BvbnNlLnByb2Nlc3NpbmdTdGF0dXMgfHwgcmVzcG9uc2UucHJvY2Vzc2luZ19zdGF0dXMgfHwgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSB8fCByZXNwb25zZS5jb250ZW50X3R5cGUgfHwgZG9jdW1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHJlc3BvbnNlLmNvbmZpZGVuY2VTY29yZSB8fCByZXNwb25zZS5jb25maWRlbmNlX3Njb3JlIHx8IGRvY3VtZW50LmNvbmZpZGVuY2VTY29yZSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogcmVzcG9uc2UuZXJyb3JNZXNzYWdlIHx8IHJlc3BvbnNlLmVycm9yX21lc3NhZ2UgfHwgZG9jdW1lbnQuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRG9jdW1lbnQgc3RhdHVzIGFmdGVyIGF0dGVtcHQgJHtyZXRyaWVzICsgMX06ICR7ZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1c31gKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRG9jdW1lbnQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7ZG9jdW1lbnQuZXJyb3JNZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcG9sbGluZyBkb2N1bWVudCBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRyeWluZyBldmVuIGlmIGFuIGluZGl2aWR1YWwgcG9sbCBmYWlsc1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXRyaWVzKys7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzICE9PSAnY29tcGxldGVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IHByb2Nlc3NpbmcgdGltZWQgb3V0IG9yIGZhaWxlZCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGVwIDM6IElmIGF1dG8tdmVyaWZ5IGlzIGVuYWJsZWQsIGNoZWNrIGFuZCBwb3RlbnRpYWxseSBlbmhhbmNlIGZpbmFuY2lhbCBkYXRhXG4gICAgICBpZiAoYXV0b1ZlcmlmeSkge1xuICAgICAgICBjb25zb2xlLmxvZygnVmVyaWZ5aW5nIGZpbmFuY2lhbCBkYXRhLi4uJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0Lmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBuZWVkcyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgY2hlY2tSZXN1bHQuZGlhZ25vc2lzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZmluYW5jaWFsIGRhdGEgaXMgbWlzc2luZyBvciBpbnN1ZmZpY2llbnQsIHRyeSB0byB2ZXJpZnkgYW5kIGVuaGFuY2UgaXRcbiAgICAgICAgICAgIGNvbnN0IHZlcmlmeVJlc3VsdCA9IGF3YWl0IHRoaXMudmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb24gcmVzdWx0OicsIHZlcmlmeVJlc3VsdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2ZXJpZnlSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAvLyBSZS1mZXRjaCB0aGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSBlbmhhbmNlZCBkYXRhXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8RG9jdW1lbnRSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnQubWV0YWRhdGEuaWR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkb2N1bWVudCA9IHtcbiAgICAgICAgICAgICAgICAuLi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIGV4dHJhY3RlZERhdGE6IHJlc3BvbnNlLmV4dHJhY3RlZERhdGEgfHwgcmVzcG9uc2UuZXh0cmFjdGVkX2RhdGEgfHwgZG9jdW1lbnQuZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgICAgICAgICBwZXJpb2RzOiByZXNwb25zZS5wZXJpb2RzIHx8IGRvY3VtZW50LnBlcmlvZHMsXG4gICAgICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IGhhcyB2YWxpZCBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSBldmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlsc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZXQgYSBzZWN1cmUgVVJMIHRvIGFjY2VzcyB0aGUgZG9jdW1lbnRcbiAgICovXG4gIGFzeW5jIGdldERvY3VtZW50VXJsKGRvY3VtZW50SWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEluc3RlYWQgb2YgbWFraW5nIGFuIEFQSSByZXF1ZXN0LCBjb25zdHJ1Y3QgdGhlIFVSTCBkaXJlY3RseVxuICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoZSBiYWNrZW5kIHNlcnZlcyBkb2N1bWVudCBjb250ZW50IGF0IHRoaXMgZW5kcG9pbnRcbiAgICAgIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jb250ZW50YDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBHZXQgYWxsIGNpdGF0aW9ucyBmb3IgYSBkb2N1bWVudFxuICAgKi9cbiAgYXN5bmMgZ2V0RG9jdW1lbnRDaXRhdGlvbnMoZG9jdW1lbnRJZDogc3RyaW5nKTogUHJvbWlzZTxDaXRhdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8QXBpQ2l0YXRpb25bXT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2l0YXRpb25zYCk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgcmVzcG9uc2UgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSBlYWNoIGNpdGF0aW9uXG4gICAgICAgIHJldHVybiByZXNwb25zZS5tYXAoY2l0YXRpb24gPT4gKHtcbiAgICAgICAgICBpZDogY2l0YXRpb24uaWQgfHwgJycsXG4gICAgICAgICAgdGV4dDogY2l0YXRpb24udGV4dCxcbiAgICAgICAgICBkb2N1bWVudElkOiBjaXRhdGlvbi5kb2N1bWVudF9pZCxcbiAgICAgICAgICBoaWdobGlnaHRJZDogY2l0YXRpb24uaGlnaGxpZ2h0X2lkLFxuICAgICAgICAgIHBhZ2U6IGNpdGF0aW9uLnBhZ2UsXG4gICAgICAgICAgcmVjdHM6IGNpdGF0aW9uLnJlY3RzLFxuICAgICAgICAgIG1lc3NhZ2VJZDogY2l0YXRpb24ubWVzc2FnZV9pZCxcbiAgICAgICAgICBhbmFseXNpc0lkOiBjaXRhdGlvbi5hbmFseXNpc19pZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBkb2N1bWVudCBjaXRhdGlvbnM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY2l0YXRpb24gaW4gYSBkb2N1bWVudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQ2l0YXRpb24oZG9jdW1lbnRJZDogc3RyaW5nLCBjaXRhdGlvbjogT21pdDxDaXRhdGlvbiwgJ2lkJz4pOiBQcm9taXNlPENpdGF0aW9uPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgdG8gc25ha2VfY2FzZSBmb3IgdGhlIEFQSVxuICAgICAgY29uc3QgYXBpQ2l0YXRpb246IEFwaUNpdGF0aW9uID0ge1xuICAgICAgICB0ZXh0OiBjaXRhdGlvbi50ZXh0LFxuICAgICAgICBkb2N1bWVudF9pZDogZG9jdW1lbnRJZCxcbiAgICAgICAgaGlnaGxpZ2h0X2lkOiBjaXRhdGlvbi5oaWdobGlnaHRJZCxcbiAgICAgICAgcGFnZTogY2l0YXRpb24ucGFnZSxcbiAgICAgICAgcmVjdHM6IGNpdGF0aW9uLnJlY3RzLFxuICAgICAgICBtZXNzYWdlX2lkOiBjaXRhdGlvbi5tZXNzYWdlSWQsXG4gICAgICAgIGFuYWx5c2lzX2lkOiBjaXRhdGlvbi5hbmFseXNpc0lkXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UucG9zdDxBcGlDaXRhdGlvbj4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2l0YXRpb25zYCwgYXBpQ2l0YXRpb24pO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGJhY2sgdG8gY2FtZWxDYXNlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcmVzcG9uc2UuaWQgfHwgJycsXG4gICAgICAgIHRleHQ6IHJlc3BvbnNlLnRleHQsXG4gICAgICAgIGRvY3VtZW50SWQ6IHJlc3BvbnNlLmRvY3VtZW50X2lkLFxuICAgICAgICBoaWdobGlnaHRJZDogcmVzcG9uc2UuaGlnaGxpZ2h0X2lkLFxuICAgICAgICBwYWdlOiByZXNwb25zZS5wYWdlLFxuICAgICAgICByZWN0czogcmVzcG9uc2UucmVjdHMsXG4gICAgICAgIG1lc3NhZ2VJZDogcmVzcG9uc2UubWVzc2FnZV9pZCxcbiAgICAgICAgYW5hbHlzaXNJZDogcmVzcG9uc2UuYW5hbHlzaXNfaWRcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVXBsb2FkIGEgZG9jdW1lbnQgd2l0aCBwcm9ncmVzcyB0cmFja2luZ1xuICAgKi9cbiAgYXN5bmMgdXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MoXG4gICAgZmlsZTogRmlsZSwgXG4gICAgb25Qcm9ncmVzcz86IChwcm9ncmVzczogbnVtYmVyKSA9PiB2b2lkXG4gICk6IFByb21pc2U8UHJvY2Vzc2VkRG9jdW1lbnQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIHByb2dyZXNzLWVuYWJsZWQgdXBsb2FkIG1ldGhvZCAtIHVzaW5nIHR5cGUgYXNzZXJ0aW9uIGZvciBzY2hlbWEgY29tcGF0aWJpbGl0eVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFwaVNlcnZpY2UudXBsb2FkV2l0aFByb2dyZXNzPERvY3VtZW50VXBsb2FkUmVzcG9uc2U+KFxuICAgICAgICAnL2FwaS9kb2N1bWVudHMvdXBsb2FkJyxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgIERvY3VtZW50VXBsb2FkUmVzcG9uc2VTY2hlbWEgYXMgYW55XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gcGxhY2Vob2xkZXIgZG9jdW1lbnQgd2l0aCB0aGUgSURcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgaWQ6IGRhdGEuZG9jdW1lbnRfaWQsXG4gICAgICAgICAgZmlsZW5hbWU6IGRhdGEuZmlsZW5hbWUsXG4gICAgICAgICAgdXBsb2FkVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZmlsZVNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICBtaW1lVHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgIHVzZXJJZDogJ2N1cnJlbnQtdXNlcicsXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnb3RoZXInLFxuICAgICAgICBleHRyYWN0aW9uVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHBlcmlvZHM6IFtdLFxuICAgICAgICBleHRyYWN0ZWREYXRhOiB7fSxcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiAwLFxuICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiBkYXRhLnN0YXR1cyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBkYXRhLnN0YXR1cyA9PT0gJ2ZhaWxlZCcgPyBkYXRhLm1lc3NhZ2UgOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIFVwbG9hZHMgYW5kIHZlcmlmaWVzIGEgZG9jdW1lbnQgd2l0aCBwcm9ncmVzcyB0cmFja2luZyxcbiAgICogZW5zdXJpbmcgaXQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhXG4gICAqL1xuICBhc3luYyB1cGxvYWRBbmRWZXJpZnlEb2N1bWVudFdpdGhQcm9ncmVzcyhcbiAgICBmaWxlOiBGaWxlLCBcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIsIHN0YWdlOiBzdHJpbmcpID0+IHZvaWQsXG4gICAgYXV0b1ZlcmlmeTogYm9vbGVhbiA9IHRydWVcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgd3JhcHBlciBmb3IgcHJvZ3Jlc3MgdGhhdCBpbmNsdWRlcyB0aGUgc3RhZ2VcbiAgICAgIGNvbnN0IHVwbG9hZFByb2dyZXNzV3JhcHBlciA9IG9uUHJvZ3Jlc3MgXG4gICAgICAgID8gKHByb2dyZXNzOiBudW1iZXIpID0+IG9uUHJvZ3Jlc3MocHJvZ3Jlc3MgKiAwLjQsICdVcGxvYWRpbmcgZmlsZScpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgXG4gICAgICAvLyBTdGVwIDE6IFVwbG9hZCB0aGUgZG9jdW1lbnQgKDQwJSBvZiB0b3RhbCBwcm9ncmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRpbmcgZG9jdW1lbnQuLi4nKTtcbiAgICAgIG9uUHJvZ3Jlc3M/LigwLCAnU3RhcnRpbmcgdXBsb2FkJyk7XG4gICAgICBjb25zdCBpbml0aWFsRG9jdW1lbnQgPSBhd2FpdCB0aGlzLnVwbG9hZERvY3VtZW50V2l0aFByb2dyZXNzKGZpbGUsIHVwbG9hZFByb2dyZXNzV3JhcHBlcik7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMjogUG9sbCBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uICg0MCUgb2YgdG90YWwgcHJvZ3Jlc3MpXG4gICAgICBjb25zb2xlLmxvZygnUG9sbGluZyBmb3IgZG9jdW1lbnQgcHJvY2Vzc2luZyBjb21wbGV0aW9uLi4uJyk7XG4gICAgICBvblByb2dyZXNzPy4oNDAsICdQcm9jZXNzaW5nIGRvY3VtZW50Jyk7XG4gICAgICBcbiAgICAgIGxldCBkb2N1bWVudCA9IGluaXRpYWxEb2N1bWVudDtcbiAgICAgIGxldCByZXRyaWVzID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzMDsgLy8gMzAgKiAyIHNlY29uZHMgPSAxIG1pbnV0ZSBtYXhcbiAgICAgIFxuICAgICAgd2hpbGUgKHJldHJpZXMgPCBtYXhSZXRyaWVzICYmIGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdjb21wbGV0ZWQnICYmIGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdmYWlsZWQnKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7IC8vIFdhaXQgMiBzZWNvbmRzXG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgZHVyaW5nIHBvbGxpbmdcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBjb25zdCBwb2xsaW5nUHJvZ3Jlc3MgPSA0MCArIE1hdGgubWluKDQwLCAocmV0cmllcyAvIG1heFJldHJpZXMpICogNDApO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MocG9sbGluZ1Byb2dyZXNzLCAnUHJvY2Vzc2luZyBkb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBGZXRjaCB0aGUgZG9jdW1lbnQncyBjdXJyZW50IHN0YXRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxEb2N1bWVudFJlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudC5tZXRhZGF0YS5pZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgZG9jdW1lbnQgd2l0aCB0aGUgbGF0ZXN0IGRhdGFcbiAgICAgICAgICBkb2N1bWVudCA9IHtcbiAgICAgICAgICAgIC4uLmRvY3VtZW50LFxuICAgICAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogcmVzcG9uc2UucHJvY2Vzc2luZ1N0YXR1cyB8fCByZXNwb25zZS5wcm9jZXNzaW5nX3N0YXR1cyB8fCBkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgIGV4dHJhY3RlZERhdGE6IHJlc3BvbnNlLmV4dHJhY3RlZERhdGEgfHwgcmVzcG9uc2UuZXh0cmFjdGVkX2RhdGEgfHwgZG9jdW1lbnQuZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgICAgIHBlcmlvZHM6IHJlc3BvbnNlLnBlcmlvZHMgfHwgZG9jdW1lbnQucGVyaW9kcyxcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiByZXNwb25zZS5lcnJvck1lc3NhZ2UgfHwgcmVzcG9uc2UuZXJyb3JfbWVzc2FnZSB8fCBkb2N1bWVudC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBEb2N1bWVudCBzdGF0dXMgYWZ0ZXIgYXR0ZW1wdCAke3JldHJpZXMgKyAxfTogJHtkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb2N1bWVudC5wcm9jZXNzaW5nU3RhdHVzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEb2N1bWVudCBwcm9jZXNzaW5nIGZhaWxlZDogJHtkb2N1bWVudC5lcnJvck1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwb2xsaW5nIGRvY3VtZW50IHN0YXR1czonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgdHJ5aW5nIGV2ZW4gaWYgYW4gaW5kaXZpZHVhbCBwb2xsIGZhaWxzXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHJpZXMrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgIT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgcHJvY2Vzc2luZyB0aW1lZCBvdXQgb3IgZmFpbGVkJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMzogSWYgYXV0by12ZXJpZnkgaXMgZW5hYmxlZCwgY2hlY2sgYW5kIHBvdGVudGlhbGx5IGVuaGFuY2UgZmluYW5jaWFsIGRhdGEgKDIwJSBvZiB0b3RhbCBwcm9ncmVzcylcbiAgICAgIGlmIChhdXRvVmVyaWZ5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdWZXJpZnlpbmcgZmluYW5jaWFsIGRhdGEuLi4nKTtcbiAgICAgICAgb25Qcm9ncmVzcz8uKDgwLCAnVmVyaWZ5aW5nIGZpbmFuY2lhbCBkYXRhJyk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFjaGVja1Jlc3VsdC5oYXNGaW5hbmNpYWxEYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgbmVlZHMgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGNoZWNrUmVzdWx0LmRpYWdub3Npcyk7XG4gICAgICAgICAgICBvblByb2dyZXNzPy4oODUsICdFbmhhbmNpbmcgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgZmluYW5jaWFsIGRhdGEgaXMgbWlzc2luZyBvciBpbnN1ZmZpY2llbnQsIHRyeSB0byB2ZXJpZnkgYW5kIGVuaGFuY2UgaXRcbiAgICAgICAgICAgIGNvbnN0IHZlcmlmeVJlc3VsdCA9IGF3YWl0IHRoaXMudmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb24gcmVzdWx0OicsIHZlcmlmeVJlc3VsdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh2ZXJpZnlSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBvblByb2dyZXNzPy4oOTAsICdSZXRyaWV2aW5nIGVuaGFuY2VkIGRhdGEnKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFJlLWZldGNoIHRoZSBkb2N1bWVudCB0byBnZXQgdGhlIGVuaGFuY2VkIGRhdGFcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxEb2N1bWVudFJlc3BvbnNlPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudC5tZXRhZGF0YS5pZH1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgICAgIC4uLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5jb250ZW50VHlwZSB8fCByZXNwb25zZS5jb250ZW50X3R5cGUgfHwgZG9jdW1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgICAgIHBlcmlvZHM6IHJlc3BvbnNlLnBlcmlvZHMgfHwgZG9jdW1lbnQucGVyaW9kcyxcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHJlc3BvbnNlLmNvbmZpZGVuY2VTY29yZSB8fCByZXNwb25zZS5jb25maWRlbmNlX3Njb3JlIHx8IGRvY3VtZW50LmNvbmZpZGVuY2VTY29yZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgZXJyb3IpO1xuICAgICAgICAgIC8vIENvbnRpbnVlIGV2ZW4gaWYgdmVyaWZpY2F0aW9uIGZhaWxzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ29tcGxldGUgdGhlIHByb2Nlc3NcbiAgICAgIG9uUHJvZ3Jlc3M/LigxMDAsICdEb2N1bWVudCByZWFkeScpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG59OyJdLCJuYW1lcyI6WyJhcGlTZXJ2aWNlIiwiRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSIsImhhbmRsZUFwaUVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwicmVzcG9uc2UiLCJkYXRhIiwiZGV0YWlsIiwiRXJyb3IiLCJkb2N1bWVudHNBcGkiLCJ1cGxvYWREb2N1bWVudCIsImZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwicG9zdEZvcm1EYXRhIiwibWV0YWRhdGEiLCJpZCIsImRvY3VtZW50X2lkIiwiZmlsZW5hbWUiLCJ1cGxvYWRUaW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmaWxlU2l6ZSIsInNpemUiLCJtaW1lVHlwZSIsInR5cGUiLCJ1c2VySWQiLCJjb250ZW50VHlwZSIsImV4dHJhY3Rpb25UaW1lc3RhbXAiLCJwZXJpb2RzIiwiZXh0cmFjdGVkRGF0YSIsImNvbmZpZGVuY2VTY29yZSIsInByb2Nlc3NpbmdTdGF0dXMiLCJzdGF0dXMiLCJlcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwibGlzdERvY3VtZW50cyIsInBhZ2UiLCJwYWdlU2l6ZSIsImdldCIsImdldERvY3VtZW50Q291bnQiLCJjb3VudCIsImNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhIiwiZG9jdW1lbnRJZCIsInZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YSIsInJldHJ5RXh0cmFjdGlvbiIsImNoZWNrUmVzcG9uc2UiLCJoYXNGaW5hbmNpYWxEYXRhIiwic3VjY2VzcyIsImRpYWdub3NpcyIsInZlcmlmeVJlc3BvbnNlIiwicG9zdCIsInJldHJ5X2V4dHJhY3Rpb24iLCJ1cGxvYWRBbmRWZXJpZnlEb2N1bWVudCIsImF1dG9WZXJpZnkiLCJsb2ciLCJpbml0aWFsRG9jdW1lbnQiLCJkb2N1bWVudCIsInJldHJpZXMiLCJtYXhSZXRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc2luZ19zdGF0dXMiLCJjb250ZW50X3R5cGUiLCJleHRyYWN0ZWRfZGF0YSIsImNvbmZpZGVuY2Vfc2NvcmUiLCJlcnJvcl9tZXNzYWdlIiwiY2hlY2tSZXN1bHQiLCJ2ZXJpZnlSZXN1bHQiLCJnZXREb2N1bWVudFVybCIsImdldERvY3VtZW50Q2l0YXRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiY2l0YXRpb24iLCJ0ZXh0IiwiaGlnaGxpZ2h0SWQiLCJoaWdobGlnaHRfaWQiLCJyZWN0cyIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJhbmFseXNpc0lkIiwiYW5hbHlzaXNfaWQiLCJjcmVhdGVDaXRhdGlvbiIsImFwaUNpdGF0aW9uIiwidXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwidXBsb2FkV2l0aFByb2dyZXNzIiwidXBsb2FkQW5kVmVyaWZ5RG9jdW1lbnRXaXRoUHJvZ3Jlc3MiLCJ1cGxvYWRQcm9ncmVzc1dyYXBwZXIiLCJwcm9ncmVzcyIsInBvbGxpbmdQcm9ncmVzcyIsIk1hdGgiLCJtaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/documents.ts\n"));

/***/ })

});