"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/workspace/page",{

/***/ "(app-pages-browser)/./src/lib/api/documents.ts":
/*!**********************************!*\
  !*** ./src/lib/api/documents.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   documentsApi: function() { return /* binding */ documentsApi; }\n/* harmony export */ });\n/* harmony import */ var _apiService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./apiService */ \"(app-pages-browser)/./src/lib/api/apiService.ts\");\n/* harmony import */ var _validation_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/validation/schemas */ \"(app-pages-browser)/./src/validation/schemas.ts\");\n\n\n// Function to handle API errors - keeping for backwards compatibility\nconst handleApiError = (error)=>{\n    console.error(\"API Error:\", error);\n    if (error.response && error.response.data && error.response.data.detail) {\n        throw new Error(error.response.data.detail);\n    }\n    throw new Error(\"An error occurred while communicating with the server\");\n};\nconst documentsApi = {\n    /**\n   * Uploads a document to the server\n   */ async uploadDocument (file) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Type assertion to resolve schema compatibility issue\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.postFormData(\"/api/documents/upload\", formData, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // For now, return a placeholder ProcessedDocument until re-processing is complete\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Lists all documents\n   */ async listDocuments () {\n        let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents?page=\".concat(page, \"&page_size=\").concat(pageSize));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Gets document count\n   */ async getDocumentCount () {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/count\");\n            return response.count;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Checks if a document has valid financial data\n   */ async checkDocumentFinancialData (documentId) {\n        try {\n            return await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Verify a document's financial data and optionally trigger re-extraction\n   */ async verifyDocumentFinancialData (documentId) {\n        let retryExtraction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        try {\n            // First check if document has financial data\n            const checkResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/check-financial-data\"));\n            // If check passes, return success\n            if (checkResponse.hasFinancialData) {\n                return {\n                    success: true,\n                    message: checkResponse.diagnosis || \"Document content available for analysis\"\n                };\n            }\n            // If check fails and retry is enabled, try verification endpoint which will accept any content\n            if (retryExtraction) {\n                const verifyResponse = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/verify-financial-data\"), {\n                    retry_extraction: true\n                });\n                return verifyResponse;\n            }\n            // Even if verification fails, we'll still allow using the document\n            // This ensures users can still try to use documents that might not have\n            // ideal structure but could still be useful\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        } catch (error) {\n            console.error(\"Error verifying document:\", error);\n            // Even if verification fails, we'll allow continuing with the document\n            return {\n                success: true,\n                message: \"Document available for analysis (verification bypassed)\"\n            };\n        }\n    },\n    /**\n   * Uploads and verifies a document, ensuring it has valid financial data\n   */ async uploadAndVerifyDocument (file) {\n        let autoVerify = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        try {\n            // Step 1: Upload the document\n            console.log(\"Uploading document...\");\n            const initialDocument = await this.uploadDocument(file);\n            // Step 2: Poll for document processing completion\n            console.log(\"Polling for document processing completion...\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get a secure URL to access the document\n   */ async getDocumentUrl (documentId) {\n        try {\n            // Create a URL to a fake PDF for testing purposes\n            // Instead of making an API request to a non-existent endpoint,\n            // we'll use a sample PDF for demonstration\n            // In a production environment, you would implement one of these approaches:\n            // 1. Add a backend endpoint that returns the document file content\n            // 2. Store documents in a cloud storage service (like S3) with pre-signed URLs\n            // 3. Implement server-sent binary responses with proper Content-Type headers\n            // For demonstration, we're using a sample PDF URL\n            return \"https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf\";\n        // When backend is ready with a proper endpoint, replace with:\n        // const response = await apiService.get<Blob>(`/api/documents/${documentId}/file`, {\n        //   responseType: 'blob'\n        // });\n        // return URL.createObjectURL(response);\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Get all citations for a document\n   */ async getDocumentCitations (documentId) {\n        try {\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(documentId, \"/citations\"));\n            // Ensure the response is an array\n            if (Array.isArray(response)) {\n                // Validate each citation\n                return response.map((citation)=>({\n                        id: citation.id || \"\",\n                        text: citation.text,\n                        documentId: citation.document_id,\n                        highlightId: citation.highlight_id,\n                        page: citation.page,\n                        rects: citation.rects,\n                        messageId: citation.message_id,\n                        analysisId: citation.analysis_id\n                    }));\n            }\n            return [];\n        } catch (error) {\n            console.error(\"Error getting document citations:\", error);\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Create a new citation in a document\n   */ async createCitation (documentId, citation) {\n        try {\n            // Convert to snake_case for the API\n            const apiCitation = {\n                text: citation.text,\n                document_id: documentId,\n                highlight_id: citation.highlightId,\n                page: citation.page,\n                rects: citation.rects,\n                message_id: citation.messageId,\n                analysis_id: citation.analysisId\n            };\n            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.post(\"/api/documents/\".concat(documentId, \"/citations\"), apiCitation);\n            // Convert response back to camelCase\n            return {\n                id: response.id || \"\",\n                text: response.text,\n                documentId: response.document_id,\n                highlightId: response.highlight_id,\n                page: response.page,\n                rects: response.rects,\n                messageId: response.message_id,\n                analysisId: response.analysis_id\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Upload a document with progress tracking\n   */ async uploadDocumentWithProgress (file, onProgress) {\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Use the progress-enabled upload method - using type assertion for schema compatibility\n            const data = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.uploadWithProgress(\"/api/documents/upload\", formData, onProgress, _validation_schemas__WEBPACK_IMPORTED_MODULE_1__.DocumentUploadResponseSchema);\n            // Return placeholder document with the ID\n            return {\n                metadata: {\n                    id: data.document_id,\n                    filename: data.filename,\n                    uploadTimestamp: new Date().toISOString(),\n                    fileSize: file.size,\n                    mimeType: file.type,\n                    userId: \"current-user\"\n                },\n                contentType: \"other\",\n                extractionTimestamp: new Date().toISOString(),\n                periods: [],\n                extractedData: {},\n                confidenceScore: 0,\n                processingStatus: data.status,\n                errorMessage: data.status === \"failed\" ? data.message : undefined\n            };\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    },\n    /**\n   * Uploads and verifies a document with progress tracking,\n   * ensuring it has valid financial data\n   */ async uploadAndVerifyDocumentWithProgress (file, onProgress) {\n        let autoVerify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        try {\n            // Create wrapper for progress that includes the stage\n            const uploadProgressWrapper = onProgress ? (progress)=>onProgress(progress * 0.4, \"Uploading file\") : undefined;\n            // Step 1: Upload the document (40% of total progress)\n            console.log(\"Uploading document...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(0, \"Starting upload\");\n            const initialDocument = await this.uploadDocumentWithProgress(file, uploadProgressWrapper);\n            // Step 2: Poll for document processing completion (40% of total progress)\n            console.log(\"Polling for document processing completion...\");\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(40, \"Processing document\");\n            let document = initialDocument;\n            let retries = 0;\n            const maxRetries = 30; // 30 * 2 seconds = 1 minute max\n            while(retries < maxRetries && document.processingStatus !== \"completed\" && document.processingStatus !== \"failed\"){\n                await new Promise((resolve)=>setTimeout(resolve, 2000)); // Wait 2 seconds\n                // Update progress during polling\n                if (onProgress) {\n                    const pollingProgress = 40 + Math.min(40, retries / maxRetries * 40);\n                    onProgress(pollingProgress, \"Processing document\");\n                }\n                // Fetch the document's current state\n                try {\n                    const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                    // Update document with the latest data\n                    document = {\n                        ...document,\n                        processingStatus: response.processingStatus || response.processing_status || document.processingStatus,\n                        contentType: response.contentType || response.content_type || document.contentType,\n                        extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                        periods: response.periods || document.periods,\n                        confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore,\n                        errorMessage: response.errorMessage || response.error_message || document.errorMessage\n                    };\n                    console.log(\"Document status after attempt \".concat(retries + 1, \": \").concat(document.processingStatus));\n                    if (document.processingStatus === \"failed\") {\n                        throw new Error(\"Document processing failed: \".concat(document.errorMessage || \"Unknown error\"));\n                    }\n                } catch (error) {\n                    console.error(\"Error polling document status:\", error);\n                // Continue trying even if an individual poll fails\n                }\n                retries++;\n            }\n            if (document.processingStatus !== \"completed\") {\n                throw new Error(\"Document processing timed out or failed\");\n            }\n            // Step 3: If auto-verify is enabled, check and potentially enhance financial data (20% of total progress)\n            if (autoVerify) {\n                console.log(\"Verifying financial data...\");\n                onProgress === null || onProgress === void 0 ? void 0 : onProgress(80, \"Verifying financial data\");\n                try {\n                    const checkResult = await this.checkDocumentFinancialData(document.metadata.id);\n                    if (!checkResult.hasFinancialData) {\n                        console.log(\"Document needs financial data verification:\", checkResult.diagnosis);\n                        onProgress === null || onProgress === void 0 ? void 0 : onProgress(85, \"Enhancing financial data\");\n                        // If financial data is missing or insufficient, try to verify and enhance it\n                        const verifyResult = await this.verifyDocumentFinancialData(document.metadata.id, true);\n                        console.log(\"Financial data verification result:\", verifyResult);\n                        if (verifyResult.success) {\n                            onProgress === null || onProgress === void 0 ? void 0 : onProgress(90, \"Retrieving enhanced data\");\n                            // Re-fetch the document to get the enhanced data\n                            const response = await _apiService__WEBPACK_IMPORTED_MODULE_0__.apiService.get(\"/api/documents/\".concat(document.metadata.id));\n                            document = {\n                                ...document,\n                                contentType: response.contentType || response.content_type || document.contentType,\n                                extractedData: response.extractedData || response.extracted_data || document.extractedData,\n                                periods: response.periods || document.periods,\n                                confidenceScore: response.confidenceScore || response.confidence_score || document.confidenceScore\n                            };\n                        }\n                    } else {\n                        console.log(\"Document has valid financial data\");\n                    }\n                } catch (error) {\n                    console.error(\"Error during financial data verification:\", error);\n                // Continue even if verification fails\n                }\n            }\n            // Complete the process\n            onProgress === null || onProgress === void 0 ? void 0 : onProgress(100, \"Document ready\");\n            return document;\n        } catch (error) {\n            throw handleApiError(error);\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDMEM7QUFLWjtBQUU5QixzRUFBc0U7QUFDdEUsTUFBTUUsaUJBQWlCLENBQUNDO0lBQ3RCQyxRQUFRRCxLQUFLLENBQUMsY0FBY0E7SUFDNUIsSUFBSUEsTUFBTUUsUUFBUSxJQUFJRixNQUFNRSxRQUFRLENBQUNDLElBQUksSUFBSUgsTUFBTUUsUUFBUSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtRQUN2RSxNQUFNLElBQUlDLE1BQU1MLE1BQU1FLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNO0lBQzVDO0lBQ0EsTUFBTSxJQUFJQyxNQUFNO0FBQ2xCO0FBMENPLE1BQU1DLGVBQWU7SUFDMUI7O0dBRUMsR0FDRCxNQUFNQyxnQkFBZUMsSUFBVTtRQUM3QixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxJQUFJQztZQUNyQkQsU0FBU0UsTUFBTSxDQUFDLFFBQVFIO1lBRXhCLHVEQUF1RDtZQUN2RCxNQUFNTCxPQUFPLE1BQU1OLG1EQUFVQSxDQUFDZSxZQUFZLENBQ3hDLHlCQUNBSCxVQUNBWCw2RUFBNEJBO1lBRzlCLGtGQUFrRjtZQUNsRixPQUFPO2dCQUNMZSxVQUFVO29CQUNSQyxJQUFJWCxLQUFLWSxXQUFXO29CQUNwQkMsVUFBVWIsS0FBS2EsUUFBUTtvQkFDdkJDLGlCQUFpQixJQUFJQyxPQUFPQyxXQUFXO29CQUN2Q0MsVUFBVVosS0FBS2EsSUFBSTtvQkFDbkJDLFVBQVVkLEtBQUtlLElBQUk7b0JBQ25CQyxRQUFRO2dCQUNWO2dCQUNBQyxhQUFhO2dCQUNiQyxxQkFBcUIsSUFBSVIsT0FBT0MsV0FBVztnQkFDM0NRLFNBQVMsRUFBRTtnQkFDWEMsZUFBZSxDQUFDO2dCQUNoQkMsaUJBQWlCO2dCQUNqQkMsa0JBQWtCM0IsS0FBSzRCLE1BQU07Z0JBQzdCQyxjQUFjN0IsS0FBSzRCLE1BQU0sS0FBSyxXQUFXNUIsS0FBSzhCLE9B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RixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXBpL2RvY3VtZW50cy50cz9lZDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2Nlc3NlZERvY3VtZW50LCBEb2N1bWVudFVwbG9hZFJlc3BvbnNlLCBDaXRhdGlvbiB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgYXBpU2VydmljZSB9IGZyb20gJy4vYXBpU2VydmljZSc7XG5pbXBvcnQgeyBcbiAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSwgXG4gIFByb2Nlc3NlZERvY3VtZW50U2NoZW1hLFxuICBDaXRhdGlvblNjaGVtYVxufSBmcm9tICdAL3ZhbGlkYXRpb24vc2NoZW1hcyc7XG5cbi8vIEZ1bmN0aW9uIHRvIGhhbmRsZSBBUEkgZXJyb3JzIC0ga2VlcGluZyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvbnN0IGhhbmRsZUFwaUVycm9yID0gKGVycm9yOiBhbnkpOiBuZXZlciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gIGlmIChlcnJvci5yZXNwb25zZSAmJiBlcnJvci5yZXNwb25zZS5kYXRhICYmIGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCB0aGUgc2VydmVyJyk7XG59O1xuXG4vLyBEZWZpbmUgcmVzcG9uc2UgdHlwZXMgZm9yIGJldHRlciB0eXBlIHNhZmV0eVxuaW50ZXJmYWNlIERvY3VtZW50Q291bnRSZXNwb25zZSB7XG4gIGNvdW50OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBEb2N1bWVudFJlc3BvbnNlIGV4dGVuZHMgUHJvY2Vzc2VkRG9jdW1lbnQge1xuICAvLyBTdXBwb3J0IHNuYWtlX2Nhc2UgYmFja2VuZCBmb3JtYXRcbiAgcHJvY2Vzc2luZ19zdGF0dXM/OiBzdHJpbmc7XG4gIGNvbnRlbnRfdHlwZT86IHN0cmluZztcbiAgZXh0cmFjdGVkX2RhdGE/OiBhbnk7XG4gIGNvbmZpZGVuY2Vfc2NvcmU/OiBudW1iZXI7XG4gIGVycm9yX21lc3NhZ2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBEb2N1bWVudFVybFJlc3BvbnNlIHtcbiAgdXJsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZSB7XG4gIGhhc0ZpbmFuY2lhbERhdGE6IGJvb2xlYW47XG4gIGRpYWdub3Npczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmluYW5jaWFsRGF0YVZlcmlmeVJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG4vLyBBUEkgY2l0YXRpb24gZm9ybWF0IChmb3IgcmVxdWVzdC9yZXNwb25zZSB0by9mcm9tIGJhY2tlbmQpXG5pbnRlcmZhY2UgQXBpQ2l0YXRpb24ge1xuICBpZD86IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICBkb2N1bWVudF9pZDogc3RyaW5nO1xuICBoaWdobGlnaHRfaWQ/OiBzdHJpbmc7XG4gIHBhZ2U6IG51bWJlcjtcbiAgcmVjdHM6IGFueVtdO1xuICBtZXNzYWdlX2lkPzogc3RyaW5nO1xuICBhbmFseXNpc19pZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGRvY3VtZW50c0FwaSA9IHtcbiAgLyoqXG4gICAqIFVwbG9hZHMgYSBkb2N1bWVudCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBhc3luYyB1cGxvYWREb2N1bWVudChmaWxlOiBGaWxlKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFR5cGUgYXNzZXJ0aW9uIHRvIHJlc29sdmUgc2NoZW1hIGNvbXBhdGliaWxpdHkgaXNzdWVcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhcGlTZXJ2aWNlLnBvc3RGb3JtRGF0YTxEb2N1bWVudFVwbG9hZFJlc3BvbnNlPihcbiAgICAgICAgJy9hcGkvZG9jdW1lbnRzL3VwbG9hZCcsXG4gICAgICAgIGZvcm1EYXRhLFxuICAgICAgICBEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIGFzIGFueVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywgcmV0dXJuIGEgcGxhY2Vob2xkZXIgUHJvY2Vzc2VkRG9jdW1lbnQgdW50aWwgcmUtcHJvY2Vzc2luZyBpcyBjb21wbGV0ZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpZDogZGF0YS5kb2N1bWVudF9pZCxcbiAgICAgICAgICBmaWxlbmFtZTogZGF0YS5maWxlbmFtZSxcbiAgICAgICAgICB1cGxvYWRUaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgdXNlcklkOiAnY3VycmVudC11c2VyJywgLy8gV291bGQgY29tZSBmcm9tIGF1dGggaW4gYSByZWFsIGFwcFxuICAgICAgICB9LFxuICAgICAgICBjb250ZW50VHlwZTogJ290aGVyJyxcbiAgICAgICAgZXh0cmFjdGlvblRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwZXJpb2RzOiBbXSxcbiAgICAgICAgZXh0cmFjdGVkRGF0YToge30sXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZTogMCxcbiAgICAgICAgcHJvY2Vzc2luZ1N0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIGVycm9yTWVzc2FnZTogZGF0YS5zdGF0dXMgPT09ICdmYWlsZWQnID8gZGF0YS5tZXNzYWdlIDogdW5kZWZpbmVkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBMaXN0cyBhbGwgZG9jdW1lbnRzXG4gICAqL1xuICBhc3luYyBsaXN0RG9jdW1lbnRzKHBhZ2U6IG51bWJlciA9IDEsIHBhZ2VTaXplOiBudW1iZXIgPSAxMCk6IFByb21pc2U8YW55W10+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGFwaVNlcnZpY2UuZ2V0KGAvYXBpL2RvY3VtZW50cz9wYWdlPSR7cGFnZX0mcGFnZV9zaXplPSR7cGFnZVNpemV9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogR2V0cyBkb2N1bWVudCBjb3VudFxuICAgKi9cbiAgYXN5bmMgZ2V0RG9jdW1lbnRDb3VudCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50Q291bnRSZXNwb25zZT4oJy9hcGkvZG9jdW1lbnRzL2NvdW50Jyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuY291bnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZG9jdW1lbnQgaGFzIHZhbGlkIGZpbmFuY2lhbCBkYXRhXG4gICAqL1xuICBhc3luYyBjaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPEZpbmFuY2lhbERhdGFDaGVja1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlTZXJ2aWNlLmdldDxGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2hlY2stZmluYW5jaWFsLWRhdGFgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBWZXJpZnkgYSBkb2N1bWVudCdzIGZpbmFuY2lhbCBkYXRhIGFuZCBvcHRpb25hbGx5IHRyaWdnZXIgcmUtZXh0cmFjdGlvblxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50SWQ6IHN0cmluZywgcmV0cnlFeHRyYWN0aW9uOiBib29sZWFuID0gZmFsc2UpOiBQcm9taXNlPEZpbmFuY2lhbERhdGFWZXJpZnlSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBkb2N1bWVudCBoYXMgZmluYW5jaWFsIGRhdGFcbiAgICAgIGNvbnN0IGNoZWNrUmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxGaW5hbmNpYWxEYXRhQ2hlY2tSZXNwb25zZT4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vY2hlY2stZmluYW5jaWFsLWRhdGFgKTtcbiAgICAgIFxuICAgICAgLy8gSWYgY2hlY2sgcGFzc2VzLCByZXR1cm4gc3VjY2Vzc1xuICAgICAgaWYgKGNoZWNrUmVzcG9uc2UuaGFzRmluYW5jaWFsRGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogY2hlY2tSZXNwb25zZS5kaWFnbm9zaXMgfHwgXCJEb2N1bWVudCBjb250ZW50IGF2YWlsYWJsZSBmb3IgYW5hbHlzaXNcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBjaGVjayBmYWlscyBhbmQgcmV0cnkgaXMgZW5hYmxlZCwgdHJ5IHZlcmlmaWNhdGlvbiBlbmRwb2ludCB3aGljaCB3aWxsIGFjY2VwdCBhbnkgY29udGVudFxuICAgICAgaWYgKHJldHJ5RXh0cmFjdGlvbikge1xuICAgICAgICBjb25zdCB2ZXJpZnlSZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UucG9zdDxGaW5hbmNpYWxEYXRhVmVyaWZ5UmVzcG9uc2U+KFxuICAgICAgICAgIGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50SWR9L3ZlcmlmeS1maW5hbmNpYWwtZGF0YWAsXG4gICAgICAgICAgeyByZXRyeV9leHRyYWN0aW9uOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFdmVuIGlmIHZlcmlmaWNhdGlvbiBmYWlscywgd2UnbGwgc3RpbGwgYWxsb3cgdXNpbmcgdGhlIGRvY3VtZW50XG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdXNlcnMgY2FuIHN0aWxsIHRyeSB0byB1c2UgZG9jdW1lbnRzIHRoYXQgbWlnaHQgbm90IGhhdmVcbiAgICAgIC8vIGlkZWFsIHN0cnVjdHVyZSBidXQgY291bGQgc3RpbGwgYmUgdXNlZnVsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLCAvLyBGb3JjZSBzdWNjZXNzIHRvIGFsbG93IGRvY3VtZW50IHVzZSByZWdhcmRsZXNzIG9mIGNvbnRlbnRcbiAgICAgICAgbWVzc2FnZTogXCJEb2N1bWVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzICh2ZXJpZmljYXRpb24gYnlwYXNzZWQpXCJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB2ZXJpZnlpbmcgZG9jdW1lbnQ6XCIsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHMsIHdlJ2xsIGFsbG93IGNvbnRpbnVpbmcgd2l0aCB0aGUgZG9jdW1lbnRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsIC8vIEZvcmNlIHN1Y2Nlc3MgdG8gYWxsb3cgZG9jdW1lbnQgdXNlXG4gICAgICAgIG1lc3NhZ2U6IFwiRG9jdW1lbnQgYXZhaWxhYmxlIGZvciBhbmFseXNpcyAodmVyaWZpY2F0aW9uIGJ5cGFzc2VkKVwiXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWRzIGFuZCB2ZXJpZmllcyBhIGRvY3VtZW50LCBlbnN1cmluZyBpdCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFZlcmlmeURvY3VtZW50KFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIGF1dG9WZXJpZnk6IGJvb2xlYW4gPSB0cnVlXG4gICk6IFByb21pc2U8UHJvY2Vzc2VkRG9jdW1lbnQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gU3RlcCAxOiBVcGxvYWQgdGhlIGRvY3VtZW50XG4gICAgICBjb25zb2xlLmxvZygnVXBsb2FkaW5nIGRvY3VtZW50Li4uJyk7XG4gICAgICBjb25zdCBpbml0aWFsRG9jdW1lbnQgPSBhd2FpdCB0aGlzLnVwbG9hZERvY3VtZW50KGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBTdGVwIDI6IFBvbGwgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvblxuICAgICAgY29uc29sZS5sb2coJ1BvbGxpbmcgZm9yIGRvY3VtZW50IHByb2Nlc3NpbmcgY29tcGxldGlvbi4uLicpO1xuICAgICAgbGV0IGRvY3VtZW50ID0gaW5pdGlhbERvY3VtZW50O1xuICAgICAgbGV0IHJldHJpZXMgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDMwOyAvLyAzMCAqIDIgc2Vjb25kcyA9IDEgbWludXRlIG1heFxuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTsgLy8gV2FpdCAyIHNlY29uZHNcbiAgICAgICAgXG4gICAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCdzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBkb2N1bWVudCB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiByZXNwb25zZS5wcm9jZXNzaW5nU3RhdHVzIHx8IHJlc3BvbnNlLnByb2Nlc3Npbmdfc3RhdHVzIHx8IGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yTWVzc2FnZSB8fCByZXNwb25zZS5lcnJvcl9tZXNzYWdlIHx8IGRvY3VtZW50LmVycm9yTWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50IHN0YXR1cyBhZnRlciBhdHRlbXB0ICR7cmV0cmllcyArIDF9OiAke2RvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXN9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2RvY3VtZW50LmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvbGxpbmcgZG9jdW1lbnQgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cnlpbmcgZXZlbiBpZiBhbiBpbmRpdmlkdWFsIHBvbGwgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RlcCAzOiBJZiBhdXRvLXZlcmlmeSBpcyBlbmFibGVkLCBjaGVjayBhbmQgcG90ZW50aWFsbHkgZW5oYW5jZSBmaW5hbmNpYWwgZGF0YVxuICAgICAgaWYgKGF1dG9WZXJpZnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YS4uLicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gYXdhaXQgdGhpcy5jaGVja0RvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFjaGVja1Jlc3VsdC5oYXNGaW5hbmNpYWxEYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgbmVlZHMgZmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uOicsIGNoZWNrUmVzdWx0LmRpYWdub3Npcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIGZpbmFuY2lhbCBkYXRhIGlzIG1pc3Npbmcgb3IgaW5zdWZmaWNpZW50LCB0cnkgdG8gdmVyaWZ5IGFuZCBlbmhhbmNlIGl0XG4gICAgICAgICAgICBjb25zdCB2ZXJpZnlSZXN1bHQgPSBhd2FpdCB0aGlzLnZlcmlmeURvY3VtZW50RmluYW5jaWFsRGF0YShkb2N1bWVudC5tZXRhZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmluYW5jaWFsIGRhdGEgdmVyaWZpY2F0aW9uIHJlc3VsdDonLCB2ZXJpZnlSZXN1bHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodmVyaWZ5UmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGRvY3VtZW50IHRvIGdldCB0aGUgZW5oYW5jZWQgZGF0YVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogR2V0IGEgc2VjdXJlIFVSTCB0byBhY2Nlc3MgdGhlIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudFVybChkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgYSBVUkwgdG8gYSBmYWtlIFBERiBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgICAgLy8gSW5zdGVhZCBvZiBtYWtpbmcgYW4gQVBJIHJlcXVlc3QgdG8gYSBub24tZXhpc3RlbnQgZW5kcG9pbnQsXG4gICAgICAvLyB3ZSdsbCB1c2UgYSBzYW1wbGUgUERGIGZvciBkZW1vbnN0cmF0aW9uXG4gICAgICBcbiAgICAgIC8vIEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgeW91IHdvdWxkIGltcGxlbWVudCBvbmUgb2YgdGhlc2UgYXBwcm9hY2hlczpcbiAgICAgIC8vIDEuIEFkZCBhIGJhY2tlbmQgZW5kcG9pbnQgdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBmaWxlIGNvbnRlbnRcbiAgICAgIC8vIDIuIFN0b3JlIGRvY3VtZW50cyBpbiBhIGNsb3VkIHN0b3JhZ2Ugc2VydmljZSAobGlrZSBTMykgd2l0aCBwcmUtc2lnbmVkIFVSTHNcbiAgICAgIC8vIDMuIEltcGxlbWVudCBzZXJ2ZXItc2VudCBiaW5hcnkgcmVzcG9uc2VzIHdpdGggcHJvcGVyIENvbnRlbnQtVHlwZSBoZWFkZXJzXG4gICAgICBcbiAgICAgIC8vIEZvciBkZW1vbnN0cmF0aW9uLCB3ZSdyZSB1c2luZyBhIHNhbXBsZSBQREYgVVJMXG4gICAgICByZXR1cm4gJ2h0dHBzOi8vd3d3LnczLm9yZy9XQUkvRVIvdGVzdHMveGh0bWwvdGVzdGZpbGVzL3Jlc291cmNlcy9wZGYvZHVtbXkucGRmJztcbiAgICAgIFxuICAgICAgLy8gV2hlbiBiYWNrZW5kIGlzIHJlYWR5IHdpdGggYSBwcm9wZXIgZW5kcG9pbnQsIHJlcGxhY2Ugd2l0aDpcbiAgICAgIC8vIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5nZXQ8QmxvYj4oYC9hcGkvZG9jdW1lbnRzLyR7ZG9jdW1lbnRJZH0vZmlsZWAsIHtcbiAgICAgIC8vICAgcmVzcG9uc2VUeXBlOiAnYmxvYidcbiAgICAgIC8vIH0pO1xuICAgICAgLy8gcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIEdldCBhbGwgY2l0YXRpb25zIGZvciBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBnZXREb2N1bWVudENpdGF0aW9ucyhkb2N1bWVudElkOiBzdHJpbmcpOiBQcm9taXNlPENpdGF0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlTZXJ2aWNlLmdldDxBcGlDaXRhdGlvbltdPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSByZXNwb25zZSBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIGVhY2ggY2l0YXRpb25cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1hcChjaXRhdGlvbiA9PiAoe1xuICAgICAgICAgIGlkOiBjaXRhdGlvbi5pZCB8fCAnJyxcbiAgICAgICAgICB0ZXh0OiBjaXRhdGlvbi50ZXh0LFxuICAgICAgICAgIGRvY3VtZW50SWQ6IGNpdGF0aW9uLmRvY3VtZW50X2lkLFxuICAgICAgICAgIGhpZ2hsaWdodElkOiBjaXRhdGlvbi5oaWdobGlnaHRfaWQsXG4gICAgICAgICAgcGFnZTogY2l0YXRpb24ucGFnZSxcbiAgICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgICAgbWVzc2FnZUlkOiBjaXRhdGlvbi5tZXNzYWdlX2lkLFxuICAgICAgICAgIGFuYWx5c2lzSWQ6IGNpdGF0aW9uLmFuYWx5c2lzX2lkXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGRvY3VtZW50IGNpdGF0aW9uczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBoYW5kbGVBcGlFcnJvcihlcnJvcik7XG4gICAgfVxuICB9LFxuICBcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjaXRhdGlvbiBpbiBhIGRvY3VtZW50XG4gICAqL1xuICBhc3luYyBjcmVhdGVDaXRhdGlvbihkb2N1bWVudElkOiBzdHJpbmcsIGNpdGF0aW9uOiBPbWl0PENpdGF0aW9uLCAnaWQnPik6IFByb21pc2U8Q2l0YXRpb24+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCB0byBzbmFrZV9jYXNlIGZvciB0aGUgQVBJXG4gICAgICBjb25zdCBhcGlDaXRhdGlvbjogQXBpQ2l0YXRpb24gPSB7XG4gICAgICAgIHRleHQ6IGNpdGF0aW9uLnRleHQsXG4gICAgICAgIGRvY3VtZW50X2lkOiBkb2N1bWVudElkLFxuICAgICAgICBoaWdobGlnaHRfaWQ6IGNpdGF0aW9uLmhpZ2hsaWdodElkLFxuICAgICAgICBwYWdlOiBjaXRhdGlvbi5wYWdlLFxuICAgICAgICByZWN0czogY2l0YXRpb24ucmVjdHMsXG4gICAgICAgIG1lc3NhZ2VfaWQ6IGNpdGF0aW9uLm1lc3NhZ2VJZCxcbiAgICAgICAgYW5hbHlzaXNfaWQ6IGNpdGF0aW9uLmFuYWx5c2lzSWRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpU2VydmljZS5wb3N0PEFwaUNpdGF0aW9uPihgL2FwaS9kb2N1bWVudHMvJHtkb2N1bWVudElkfS9jaXRhdGlvbnNgLCBhcGlDaXRhdGlvbik7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgcmVzcG9uc2UgYmFjayB0byBjYW1lbENhc2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXNwb25zZS5pZCB8fCAnJyxcbiAgICAgICAgdGV4dDogcmVzcG9uc2UudGV4dCxcbiAgICAgICAgZG9jdW1lbnRJZDogcmVzcG9uc2UuZG9jdW1lbnRfaWQsXG4gICAgICAgIGhpZ2hsaWdodElkOiByZXNwb25zZS5oaWdobGlnaHRfaWQsXG4gICAgICAgIHBhZ2U6IHJlc3BvbnNlLnBhZ2UsXG4gICAgICAgIHJlY3RzOiByZXNwb25zZS5yZWN0cyxcbiAgICAgICAgbWVzc2FnZUlkOiByZXNwb25zZS5tZXNzYWdlX2lkLFxuICAgICAgICBhbmFseXNpc0lkOiByZXNwb25zZS5hbmFseXNpc19pZFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgaGFuZGxlQXBpRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBVcGxvYWQgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nXG4gICAqL1xuICBhc3luYyB1cGxvYWREb2N1bWVudFdpdGhQcm9ncmVzcyhcbiAgICBmaWxlOiBGaWxlLCBcbiAgICBvblByb2dyZXNzPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWRcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWREb2N1bWVudD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgcHJvZ3Jlc3MtZW5hYmxlZCB1cGxvYWQgbWV0aG9kIC0gdXNpbmcgdHlwZSBhc3NlcnRpb24gZm9yIHNjaGVtYSBjb21wYXRpYmlsaXR5XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYXBpU2VydmljZS51cGxvYWRXaXRoUHJvZ3Jlc3M8RG9jdW1lbnRVcGxvYWRSZXNwb25zZT4oXG4gICAgICAgICcvYXBpL2RvY3VtZW50cy91cGxvYWQnLFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgRG9jdW1lbnRVcGxvYWRSZXNwb25zZVNjaGVtYSBhcyBhbnlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBwbGFjZWhvbGRlciBkb2N1bWVudCB3aXRoIHRoZSBJRFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBpZDogZGF0YS5kb2N1bWVudF9pZCxcbiAgICAgICAgICBmaWxlbmFtZTogZGF0YS5maWxlbmFtZSxcbiAgICAgICAgICB1cGxvYWRUaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBmaWxlU2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgIG1pbWVUeXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgdXNlcklkOiAnY3VycmVudC11c2VyJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudFR5cGU6ICdvdGhlcicsXG4gICAgICAgIGV4dHJhY3Rpb25UaW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGVyaW9kczogW10sXG4gICAgICAgIGV4dHJhY3RlZERhdGE6IHt9LFxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IDAsXG4gICAgICAgIHByb2Nlc3NpbmdTdGF0dXM6IGRhdGEuc3RhdHVzLFxuICAgICAgICBlcnJvck1lc3NhZ2U6IGRhdGEuc3RhdHVzID09PSAnZmFpbGVkJyA/IGRhdGEubWVzc2FnZSA6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0sXG4gIFxuICAvKipcbiAgICogVXBsb2FkcyBhbmQgdmVyaWZpZXMgYSBkb2N1bWVudCB3aXRoIHByb2dyZXNzIHRyYWNraW5nLFxuICAgKiBlbnN1cmluZyBpdCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGFcbiAgICovXG4gIGFzeW5jIHVwbG9hZEFuZFZlcmlmeURvY3VtZW50V2l0aFByb2dyZXNzKFxuICAgIGZpbGU6IEZpbGUsIFxuICAgIG9uUHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IG51bWJlciwgc3RhZ2U6IHN0cmluZykgPT4gdm9pZCxcbiAgICBhdXRvVmVyaWZ5OiBib29sZWFuID0gdHJ1ZVxuICApOiBQcm9taXNlPFByb2Nlc3NlZERvY3VtZW50PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB3cmFwcGVyIGZvciBwcm9ncmVzcyB0aGF0IGluY2x1ZGVzIHRoZSBzdGFnZVxuICAgICAgY29uc3QgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyID0gb25Qcm9ncmVzcyBcbiAgICAgICAgPyAocHJvZ3Jlc3M6IG51bWJlcikgPT4gb25Qcm9ncmVzcyhwcm9ncmVzcyAqIDAuNCwgJ1VwbG9hZGluZyBmaWxlJylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBcbiAgICAgIC8vIFN0ZXAgMTogVXBsb2FkIHRoZSBkb2N1bWVudCAoNDAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgY29uc29sZS5sb2coJ1VwbG9hZGluZyBkb2N1bWVudC4uLicpO1xuICAgICAgb25Qcm9ncmVzcz8uKDAsICdTdGFydGluZyB1cGxvYWQnKTtcbiAgICAgIGNvbnN0IGluaXRpYWxEb2N1bWVudCA9IGF3YWl0IHRoaXMudXBsb2FkRG9jdW1lbnRXaXRoUHJvZ3Jlc3MoZmlsZSwgdXBsb2FkUHJvZ3Jlc3NXcmFwcGVyKTtcbiAgICAgIFxuICAgICAgLy8gU3RlcCAyOiBQb2xsIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24gKDQwJSBvZiB0b3RhbCBwcm9ncmVzcylcbiAgICAgIGNvbnNvbGUubG9nKCdQb2xsaW5nIGZvciBkb2N1bWVudCBwcm9jZXNzaW5nIGNvbXBsZXRpb24uLi4nKTtcbiAgICAgIG9uUHJvZ3Jlc3M/Lig0MCwgJ1Byb2Nlc3NpbmcgZG9jdW1lbnQnKTtcbiAgICAgIFxuICAgICAgbGV0IGRvY3VtZW50ID0gaW5pdGlhbERvY3VtZW50O1xuICAgICAgbGV0IHJldHJpZXMgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDMwOyAvLyAzMCAqIDIgc2Vjb25kcyA9IDEgbWludXRlIG1heFxuICAgICAgXG4gICAgICB3aGlsZSAocmV0cmllcyA8IG1heFJldHJpZXMgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcgJiYgZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTsgLy8gV2FpdCAyIHNlY29uZHNcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBkdXJpbmcgcG9sbGluZ1xuICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgIGNvbnN0IHBvbGxpbmdQcm9ncmVzcyA9IDQwICsgTWF0aC5taW4oNDAsIChyZXRyaWVzIC8gbWF4UmV0cmllcykgKiA0MCk7XG4gICAgICAgICAgb25Qcm9ncmVzcyhwb2xsaW5nUHJvZ3Jlc3MsICdQcm9jZXNzaW5nIGRvY3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZldGNoIHRoZSBkb2N1bWVudCdzIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBkb2N1bWVudCB3aXRoIHRoZSBsYXRlc3QgZGF0YVxuICAgICAgICAgIGRvY3VtZW50ID0ge1xuICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICBwcm9jZXNzaW5nU3RhdHVzOiByZXNwb25zZS5wcm9jZXNzaW5nU3RhdHVzIHx8IHJlc3BvbnNlLnByb2Nlc3Npbmdfc3RhdHVzIHx8IGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUgfHwgcmVzcG9uc2UuY29udGVudF90eXBlIHx8IGRvY3VtZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgZXh0cmFjdGVkRGF0YTogcmVzcG9uc2UuZXh0cmFjdGVkRGF0YSB8fCByZXNwb25zZS5leHRyYWN0ZWRfZGF0YSB8fCBkb2N1bWVudC5leHRyYWN0ZWREYXRhLFxuICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlOiByZXNwb25zZS5jb25maWRlbmNlU2NvcmUgfHwgcmVzcG9uc2UuY29uZmlkZW5jZV9zY29yZSB8fCBkb2N1bWVudC5jb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHJlc3BvbnNlLmVycm9yTWVzc2FnZSB8fCByZXNwb25zZS5lcnJvcl9tZXNzYWdlIHx8IGRvY3VtZW50LmVycm9yTWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERvY3VtZW50IHN0YXR1cyBhZnRlciBhdHRlbXB0ICR7cmV0cmllcyArIDF9OiAke2RvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXN9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRvY3VtZW50LnByb2Nlc3NpbmdTdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VtZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2RvY3VtZW50LmVycm9yTWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBvbGxpbmcgZG9jdW1lbnQgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgICAgICAvLyBDb250aW51ZSB0cnlpbmcgZXZlbiBpZiBhbiBpbmRpdmlkdWFsIHBvbGwgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0cmllcysrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZG9jdW1lbnQucHJvY2Vzc2luZ1N0YXR1cyAhPT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU3RlcCAzOiBJZiBhdXRvLXZlcmlmeSBpcyBlbmFibGVkLCBjaGVjayBhbmQgcG90ZW50aWFsbHkgZW5oYW5jZSBmaW5hbmNpYWwgZGF0YSAoMjAlIG9mIHRvdGFsIHByb2dyZXNzKVxuICAgICAgaWYgKGF1dG9WZXJpZnkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1ZlcmlmeWluZyBmaW5hbmNpYWwgZGF0YS4uLicpO1xuICAgICAgICBvblByb2dyZXNzPy4oODAsICdWZXJpZnlpbmcgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBhd2FpdCB0aGlzLmNoZWNrRG9jdW1lbnRGaW5hbmNpYWxEYXRhKGRvY3VtZW50Lm1ldGFkYXRhLmlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoZWNrUmVzdWx0Lmhhc0ZpbmFuY2lhbERhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBuZWVkcyBmaW5hbmNpYWwgZGF0YSB2ZXJpZmljYXRpb246JywgY2hlY2tSZXN1bHQuZGlhZ25vc2lzKTtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig4NSwgJ0VuaGFuY2luZyBmaW5hbmNpYWwgZGF0YScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBmaW5hbmNpYWwgZGF0YSBpcyBtaXNzaW5nIG9yIGluc3VmZmljaWVudCwgdHJ5IHRvIHZlcmlmeSBhbmQgZW5oYW5jZSBpdFxuICAgICAgICAgICAgY29uc3QgdmVyaWZ5UmVzdWx0ID0gYXdhaXQgdGhpcy52ZXJpZnlEb2N1bWVudEZpbmFuY2lhbERhdGEoZG9jdW1lbnQubWV0YWRhdGEuaWQsIHRydWUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbiByZXN1bHQ6JywgdmVyaWZ5UmVzdWx0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHZlcmlmeVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M/Lig5MCwgJ1JldHJpZXZpbmcgZW5oYW5jZWQgZGF0YScpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmUtZmV0Y2ggdGhlIGRvY3VtZW50IHRvIGdldCB0aGUgZW5oYW5jZWQgZGF0YVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaVNlcnZpY2UuZ2V0PERvY3VtZW50UmVzcG9uc2U+KGAvYXBpL2RvY3VtZW50cy8ke2RvY3VtZW50Lm1ldGFkYXRhLmlkfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4uZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlIHx8IHJlc3BvbnNlLmNvbnRlbnRfdHlwZSB8fCBkb2N1bWVudC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWREYXRhOiByZXNwb25zZS5leHRyYWN0ZWREYXRhIHx8IHJlc3BvbnNlLmV4dHJhY3RlZF9kYXRhIHx8IGRvY3VtZW50LmV4dHJhY3RlZERhdGEsXG4gICAgICAgICAgICAgICAgcGVyaW9kczogcmVzcG9uc2UucGVyaW9kcyB8fCBkb2N1bWVudC5wZXJpb2RzLFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogcmVzcG9uc2UuY29uZmlkZW5jZVNjb3JlIHx8IHJlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUgfHwgZG9jdW1lbnQuY29uZmlkZW5jZVNjb3JlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoYXMgdmFsaWQgZmluYW5jaWFsIGRhdGEnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGZpbmFuY2lhbCBkYXRhIHZlcmlmaWNhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgZXZlbiBpZiB2ZXJpZmljYXRpb24gZmFpbHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb21wbGV0ZSB0aGUgcHJvY2Vzc1xuICAgICAgb25Qcm9ncmVzcz8uKDEwMCwgJ0RvY3VtZW50IHJlYWR5Jyk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGhhbmRsZUFwaUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbImFwaVNlcnZpY2UiLCJEb2N1bWVudFVwbG9hZFJlc3BvbnNlU2NoZW1hIiwiaGFuZGxlQXBpRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJyZXNwb25zZSIsImRhdGEiLCJkZXRhaWwiLCJFcnJvciIsImRvY3VtZW50c0FwaSIsInVwbG9hZERvY3VtZW50IiwiZmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJwb3N0Rm9ybURhdGEiLCJtZXRhZGF0YSIsImlkIiwiZG9jdW1lbnRfaWQiLCJmaWxlbmFtZSIsInVwbG9hZFRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImZpbGVTaXplIiwic2l6ZSIsIm1pbWVUeXBlIiwidHlwZSIsInVzZXJJZCIsImNvbnRlbnRUeXBlIiwiZXh0cmFjdGlvblRpbWVzdGFtcCIsInBlcmlvZHMiLCJleHRyYWN0ZWREYXRhIiwiY29uZmlkZW5jZVNjb3JlIiwicHJvY2Vzc2luZ1N0YXR1cyIsInN0YXR1cyIsImVycm9yTWVzc2FnZSIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJsaXN0RG9jdW1lbnRzIiwicGFnZSIsInBhZ2VTaXplIiwiZ2V0IiwiZ2V0RG9jdW1lbnRDb3VudCIsImNvdW50IiwiY2hlY2tEb2N1bWVudEZpbmFuY2lhbERhdGEiLCJkb2N1bWVudElkIiwidmVyaWZ5RG9jdW1lbnRGaW5hbmNpYWxEYXRhIiwicmV0cnlFeHRyYWN0aW9uIiwiY2hlY2tSZXNwb25zZSIsImhhc0ZpbmFuY2lhbERhdGEiLCJzdWNjZXNzIiwiZGlhZ25vc2lzIiwidmVyaWZ5UmVzcG9uc2UiLCJwb3N0IiwicmV0cnlfZXh0cmFjdGlvbiIsInVwbG9hZEFuZFZlcmlmeURvY3VtZW50IiwiYXV0b1ZlcmlmeSIsImxvZyIsImluaXRpYWxEb2N1bWVudCIsImRvY3VtZW50IiwicmV0cmllcyIsIm1heFJldHJpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJwcm9jZXNzaW5nX3N0YXR1cyIsImNvbnRlbnRfdHlwZSIsImV4dHJhY3RlZF9kYXRhIiwiY29uZmlkZW5jZV9zY29yZSIsImVycm9yX21lc3NhZ2UiLCJjaGVja1Jlc3VsdCIsInZlcmlmeVJlc3VsdCIsImdldERvY3VtZW50VXJsIiwiZ2V0RG9jdW1lbnRDaXRhdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJjaXRhdGlvbiIsInRleHQiLCJoaWdobGlnaHRJZCIsImhpZ2hsaWdodF9pZCIsInJlY3RzIiwibWVzc2FnZUlkIiwibWVzc2FnZV9pZCIsImFuYWx5c2lzSWQiLCJhbmFseXNpc19pZCIsImNyZWF0ZUNpdGF0aW9uIiwiYXBpQ2l0YXRpb24iLCJ1cGxvYWREb2N1bWVudFdpdGhQcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJ1cGxvYWRXaXRoUHJvZ3Jlc3MiLCJ1cGxvYWRBbmRWZXJpZnlEb2N1bWVudFdpdGhQcm9ncmVzcyIsInVwbG9hZFByb2dyZXNzV3JhcHBlciIsInByb2dyZXNzIiwicG9sbGluZ1Byb2dyZXNzIiwiTWF0aCIsIm1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api/documents.ts\n"));

/***/ })

});